1.网络通信的七层协议

  应用层

  表示层

  会话层

  传输层

  网络层

  数据链路层

  物理层

2.Http与Https

  -Http协议 

  超文本传输协议;我们的网络通信一般都是基于Http协议的;

  Http是不安全的，没有进行数据加密,没有进行数据完整性验证,

  没有验证数据通信双方的合法性;

  所以Http是不安全的;

  而Android P开始 Android禁止明文流量的网络请求,所以Http请求是不允许的;

  包括WebView加载Http链接也是不被允许的，只能使用Https请求;

  包括使用第三方图片加载框架加载http链接的图片也是无法加载的；

  -Https协议 

   Https协议是安全的Http协议; Https=Http+SSL/TLS

   Https协议对通信数据进行了加密,对通信的数据进行了完整性验证，

   保证通信双方的合法性；
   
   Https请求的过程:

   -客户端向服务器端发起请求

   -服务器端有一对公钥和私钥，接收到客户端端的请求之后，首先将公钥发送给客户端
    
    实际上是数字证书发送给客户端

   -客户端接收到公钥后，需要验证公钥是否合法，实际上是验证数字证书是否合法

    如果合法，客户端会生成对称加密的秘钥；然后使用接收到服务器的公钥对

    生成的对称加密秘钥进行加密，发送给服务器端；

   -服务器接收到客户端加密之后的堆成加密秘钥，使用私钥解密，然后使用解密出来的秘钥
   
   对响应数据进行加密，然后发送给客户端

   -客户端接收到服务器加密之后的响应数据，使用之前接收到的公钥进行解密;

     这样一次Https请求流程完成;

  -数字证书
  
   上面的一次Https请求流程中,客户端会接收服务器端的公钥，如果客户端发起请求后，服务器返回

   公钥时，被黑客拦截了，修改了公钥,将公钥改成了黑客自己的公钥,所以客户端怎么确定接收到的

   公钥是合法的，这就需要使用一个中间担保人的角色，也就是数字证书认证中心(Certificate Authority)的存在；

   也就是专门给公钥做担保的机构，全球知名的认证机构有100多个，这些知名的认证机构是全球都认可的;

   那么CA如何对公钥进行担保呢，CA本身也有一对公钥和私钥，在服务器端使用私钥对要发送的公钥进行加密，
   
   然后将加密之后的公钥以及证书的过期时间，颁发给，以及颁发者这些信息组成数字证书，将数字证书发送给客户端，

   不论什么平台，都会内置一些全球公认的CA，这些内置的数字认证机构里实际就是存储了CA的公钥，客户端

   接收到数字证书后，使用内置的CA的公钥对数字证书中的公钥进行解密，如果解密不成功，说明接收到的数字证书不是由

   知名的CA颁发的,客户端是无法信任这样的服务器证书的; 如果内置的一个CA中的公钥可以解密数字证书中的公钥，就说明

   该数字证书就是由该CA签发的,是值得信任的；

   除了能够解密出公钥，客户端还要检查当前访问的域名是否与证书中的颁发给一致，还要检查数字证书是否过期等;

3. Session和Cookie

   Http请求时一种无状态的请求,即每次服务端接收到客户端的请求都是全新的一次请求，服务端并不知道客户端的历史请求记录

   Session和Cookie是用来弥补Http的这种无状态的缺陷的;

4.TCP连接中的三次握手，四次握手

  -三次握手是建立连接的过程，四次握手断开连接的过程；

  -三次握手过程

   第一次握手：首先客户端向服务器发送SYN=1,Sequence=X的报文

   第二次握手：服务器收到SYN=1的报文，向客户端回复确认报文 ACK=X+1,SYN=Y的报文

   第三次握手：客户端接收到服务器的确认报文后，再向服务器发送一个确认报文 ACK=y+1,Sequence=Z

   三次握手之后，服务器与客户端建立起连接,才开始真正的数据传输

 -四次握手

  建立起TCP连接后，连接双方，任意一方都可以主动断开连接；

  第一次握手：主动关闭方发送一个FIN=1,Sequence=u报文，并且关闭到被动关闭方的数据传输，但是主动关闭方还是可以接收数据的

             这时候主动关闭一方进入FIN_WAIT_1状态 

  第二次握手：被动关闭方接收到FIN=1,Sequence=u的报文后，回复确认报文 ACK=u+1，Sequence=v,但是如果还有数据需要发送给主动关闭方，

             是继续发送的  

             这个时候被动关闭一方进入CLOSE_WAIT状态 

  第三次握手：还是被动关闭方发送报文，当被动关闭方没有数据要继续发送给主动关闭方，则发送FIN=1的报文,ACK=u+1,Sequence=w

             这个时候主动关闭一方进入FIN_WAIT_2状态，被动关闭一方进入的是LAST_ACK状态 
    
  第四次握手：主动关闭方收到被动关闭方的FIN报文后，回复确认报文 ACK=w+1,seq=u+1

             但是主动关闭方进入TIME_WAIT状态，等待2MSL(MSL是网络中报文存在的最大时间) 

-为什么四次握手中，最终，主动关闭方还要进入TIMW_WAIT状态，等待2MSL

 因为主动关闭方在第四次握手时，发送确认包ACK给被动关闭方，如果这个确认包ACK丢失，被动关闭方

 就收不到确认包，就会重新发送FIN包到主动关闭方，主动关闭方如果不等待，直接进入了CLOSED状态，

 就收不到重发的FIN包，也无法重新回复ACK包了

 5.DNS

 -DNS(Domain Name System)

  在网络通信中，源地址和目标地址都是以IP地址形式存在，但是作为用户来说，记住

  一串纯数字的IP地址可能就比较困难，记住一个有意义的名字可能就比较容易，所以

  就出现了域名，而DNS就是将域名和IP地址一一对应起来的；

  当我们再浏览器中输入网址，访问某个网站的时候，第一步就要通过DNS将域名转成

  IP地址，然后才建立连接;

  -DNS污染

   DNS污染实际就是DNS缓存污染,是指一些可以制造或无意制造出来的域名服务器数据

   包,把域名指向不正确的IP地址，一般来说，在互联网上都有可信任的域名服务器，

   但是为了减低网络上的流量压力，一般的域名服务器都会把从上游的域名服务器获

   得的解析记录暂存下来，下次有机器要解析域名时，可以立即提供服务，一旦有域

   名服务器的缓存受到污染，就会将访问域名的主机引到错误的域名服务器或者网址

   ；

  -抓包工具： Wireshare(不能看Https中的包) ，Charles(可以看Https中的包)
  
6.WebSocket协议

  -WebSocket与Http协议一样是一个应用层协议,WebSocket是HTML5开始

  提供的一个在单个TCP连接上进行的全双工通讯协议,允许服务端主动向客户端

  推送数据；

  WebSocket首先经过TCP三次握手建立TCP连接，然后通过Http协议进行一次握手

  建立连接;

  -WebSocket与Socket
  
   我们知道WebSocket是一个应用层协议，是在TCP连接上支持全双工的通信

   也即服务端可以主动推送数据到客户端；

   Socket其实并不是一个协议，是为了方便使用TCP或者UDP而抽象出来的一层

   是位于应用层和传输层之间的一组接口； 

   当两台主机通信时，必须使用Socket连接，Socket连接则利用TCP/IP协议建立

   TCP连接，TCP连接则依靠更底层的IP协议，IP协议的连接则依赖于数据链路层

   等更底层；






























   		     













