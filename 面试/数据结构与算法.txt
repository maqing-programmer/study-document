1.常用的数据结构

  -数据结构

  计算机存储，组织数据的方式;

  -常用的数据结构主要有四大类

  -线性表

  （1）链式存储结构 (链表)
       
       代表：LinkedList  

   (2) 顺序存储结构 (数组）

       代表:ArrayList 

  -栈 （Stack）
   
   Java中 java.util.Stack<E> 可以用来表示栈

  -队列 (Queue)

   Java中 java.util.Queue<E> 可以用来表示队列

  -哈希表

  代表：HashMap ,LinkedHashMap

  -树

  -图

2.常见的算法

  (1)排序算法
    
      快速排序

      -核心思想

      通过一趟排序将要排序的数据分成两个部分，其中一部分所有的数据要比另外一个部分的所有

      数据都要小,然后再按照此方法对这两个部分分别进行快速排序，也就是递归进行，直到分出来

      的两个部分都只有一个数的时候结束，这个时候实际上整个数据就是有序的了;

      -排序步骤

       一趟排序算法：

       一个数组：a[] 长度为length

       -设置变量start,end  i,j,初始的时候 start=0,end=length-1,i=0,j=length-1；

       -以数组中第一个元素作为关键数据key,即a[0]=key;

       -从j开始由后向前搜索(j--)，找到第一个比key小的数据

        从i开始从前向后搜索(i++),找到第一个比key大的数据

        然后交换a[i]和a[j]的值

       -然后重复第三步，直到i==j 时结束第一趟排序；

       -然后分别使用快速排序排序对[start，i-1]和[j+1,end]两部分的 

        数据进行上述排序过程；

      -Java实现
      
    /**
     * 快速排序算法
     */
    private void quickSort(int[] array, int start, int end) {

        int key = array[start];
        int i = start;
        int j = end;

        while (i < j) {

            while ((i < j) && array[i] < key) {
                i++;
            }

            while ((i < j) && array[j] > key) {
                j--;
            }

            if (array[i] == array[j] && i < j) {
                i++; //这里写i++或者j--都是可以的
            } else {
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }

        if (i - 1 > start) {
            quickSort(array, start, i - 1);
        }

        if (j + 1 < end) {
            quickSort(array, j + 1, end);
        }

    }  

(2)递归算法

   在上面排序算法我们使用到了递归算法，我们就来学习一下递归算法; 

   -核心思想

    就是将一个问题重复分解为相同类型的子问题，重复调用自身方法的算法

(3)分治算法

   -核心思想    

    将一个规模为N的问题，分解成K个规模较小的子问题，这个子问题相互独立且与原问题性质相同，

    求出子问题的解，就可以得出原问题的解

   -使用分治算法的经典问题

     -二分查找

      二分查找是一种高效的查找方法，但是要求是顺序存储结构，并且数据是有序的; 

      在一个有序数组中查找一个数，返回下标

    /**
     * 二分查找
     *
     * @param array
     * @param target
     * @return
     */
    private int binarySearch(int array[], int target) {
        int left = 0, right = array.length - 1;
        int middle;
        while (left <= right) {
            middle = (left + right) / 2;
            if (array[middle] > target) {
                right = middle - 1;
            } else if (array[middle] < target) {
                left = middle + 1;
            } else {
                return middle;
            }
        }
        return -1;
    }


(4)二叉查找树

   二叉查找树是一棵空树,或者是具有以下性质的二叉树，若它的左子树不为空，则左子树上所有节点的值

   均小于根节点的值，若它的右子树不为空，则右子树上所有节点的值均大于根节点的值,然后左右子树均

   为二叉查找树；

   































