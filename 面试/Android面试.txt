1.Activity的启动模式

  (1)standard 启动模式

     以该种方式启动Activity，无论该Activtiy实例是否在任务栈中存在一定会创建Activity的实例

  (2)singleTop启动模式

     以该种方式启动的Activity，如果该Activtiy实例不存在，或者实例存在但是不是位于任务栈的

     栈顶，则创建Activity的实例，

     如果Activity的实例已经存在并且是位于任务栈的栈顶，则直接复用即可,复用时会回调

     onNewIntent方法

   (3)SingleTask 启动模式

      以该种方式启动的Activity，如果Activity的实例不存在，则会创建Activity的实例

      如果Activity的实例已经存在，则移除任务栈中处于Activity之上的其它Activtiy，使

      目标Activity位于栈顶,复用该Activity，复用时会回调onNewIntent方法

   (4)SingleInstance启动模式
   
      以该种方式启动的Activity，如果该Activity实例不存在，则首先创建一个新的任务栈，

      然后创建Activity的实例，放入该栈中

      如果该Activity的实例已经存在，则将Activity的栈移到前台即可,复用该Activity，

      复用时会回调onNewIntent方法 

  -与启动模式相关Intent的FLAG

   (1)FLAG_ACTIVITY_NEW_TASK  
     
      -如果在非Activity中启动Activity，Intent必须要设置FLAG_ACTIVITY_NEW_TASK

      否则启动会报错

      -FLAG_ACTIVITY_NEW_TASK标签必须配合taskAffinity属性使用，如果不设置taskAffinity属

      性值，将不会生成新task
      
     -taskAffinity 表示Activity所在的任务栈

      默认情况下，应用中所有的Activity具有相同的taskAffinity,即应用程序的包名
      
      taskAffinity可以影响当Activitt是以FLAG_ACTIVITY_NEW_TASK这个FLAG标志

      启动时被放到哪个栈中
    
   (2)FLAG_ACTIVITY_SINGLE_TOP

     使用这种FLAG启动Activity，和启动模式SingleTop效果完全一样 
       
     如果该Activtiy实例不存在，或者实例存在但是不是位于任务栈的

     栈顶，则创建Activity的实例，

     如果Activity的实例已经存在并且是位于任务栈的栈顶，则直接复用即可,复用时会回调

     onNewIntent方法

   (3)FLAG_ACTIVITY_CLEAR_TASK

      必须和FLAG_ACTIVITY_NEW_TASK配合使用，否则没有效果，配合使用的效果是
      
      启动Activity时，如果同时使用这两个标记，则会清空目标Activity处于同一个

      栈中的所有Activity(这里要注意的时，但是我们
     
      知道默认情况下Activity的taskAffinity,即处于同一个栈中，所以即使目标Activity实例不存

      在也会清空和目标Activity taskAffinity一样的栈的所有Activity

      )，然后创建目标Activity实例放入栈中

   (4)FLAG_ACTIVITY_CLEAR_TOP

       使用该FLAG启动Activity，如果目标Activity实例已经存在,则会移除栈中目标Activity

       之上的所有Activity，但是对于目标Activity，是复用，还是先删除再重建,有以下规则：

      -如果是单独使用FLAG_ACTIVITY_CLEAR_TOP 

       如果目标Activity使用的是非standard启动模式，则会复用目标Activity
      
       实例,复用会回调onNewIntent方法，否则都是先删除再重建   

      -若是使用 FLAG_ACTIVITY_SINGLE_TOP 和 FLAG_ACTIVITY_CLEAR_TOP 

       标志位组合，那么不管目标 Activity 是什么启动模式，都会被复用，复用会

       回调onNewIntent方法

  特殊情况： 

  (1)使用SingleInstance模式启动某Activity，

  然后按Home键退出到后台，然后再点击应用图标回到应用中，发现该Activity被关闭了，显示的是

  上一个Activity，但是如果是从后台任务进程中重新回到应用则还是在该Activity

  (2)使用FLAG_ACTIVITY_NEW_TASK的FLAG启动Activity

     如果是startActivityForResult方式启动，会立即回调 onActivityResult

     并且resultCode为Activity.RESULT_CANCELED

2.Service

  -Service中可以直接执行耗时操作吗？

  Service是运行在主线程中的，所以不能在Service中的某个生命周期函数中

  执行耗时操作，因为会阻塞UI，可以开启一个子线程来执行耗时操作。

  也可以使用IntentService,IntentService是继承自Service的,

  IntentService中的onHandleIntent方法是工作在子线程中的，可以执行耗时操作

  在onHandleIntent方法执行完之后，IntentService会自动销毁

  -Service根据优先级进行分类

  -IntentService 

   IntentService是继承自Service的，内部是通过HandlerThread实现切换到子线程中

   执行onHanleIntent方法;

   onHandleIntent执行完毕之后，Service就会被销毁;

   所以onHandleIntent中可以执行耗时操作

3.BroadCastReceiver

4.怎么判断一个Activity是否还在运行

  if(activity==null||activity.isFinishing（）||activity.isDestored()）{
  
     //Activity的实例为null，activity.isFinishing()返回true,或者 //activity.isDestored()返回true 都表明Activtiy不再运行

  }  

  public boolean isFinishing() {
        return mFinished;
    }

  isFinishing方法返回的的mFinished字段是在finish() 中进行赋值的 

  所以只有Activity调用finish()方法关闭，才会置为true。

  但是在内存紧张时，Activity被回收，isFinishing就会判断不准了

  所以我们还加了isDestored方法来判断

5.自定义View的状态的是如何保存的

  我们知道Activity在屏幕发生旋转时，如果不做任何设置会发生销毁和重建

  销毁之前会回调onSaveInstanceState用于保存状态

  在重新创建的时候会回调 onRestoreInstanceState 方法可以拿到之前保存的状态

  Activity的onSaveInstanceState方法默认实现会调用其中所有View的onSaveInstanceState

  方法,Activity重建时会调用onRestoreInstanceState方法，默认实现会调用所有View的

  onRestoreInstanceState方法

  所以上面的问题：我们只需要重写View的onSaveInstanceState和onRestoreInstanceState

                 方法，在里面进行状态的保存和恢复即可

   具体实现我们可以参照TextView，首先定义一个类继承自BaseSavedState
   
   定义需要保存的状态属性，在onSaveInstanceState把属性保存到BaseSavedState中

   然后在onRestoreInstanceState中拿到保存的BaseSavedState,拿到保存的属性即可

     @Nullable
    @Override
    protected Parcelable onSaveInstanceState() {
        super.onSaveInstanceState();
        Log.e(TAG, "onSaveInstanceState: ");
        SavedState savedState = new SavedState(AbsSavedState.EMPTY_STATE);
        savedState.mColor = mColor;
        return savedState;
    }

    @Override
    protected void onRestoreInstanceState(Parcelable state) {
        Log.e(TAG, "onRestoreInstanceState: ");
        super.onRestoreInstanceState(state);
        mColor = ((SavedState) state).mColor;
    }

    public static class SavedState extends BaseSavedState {
        int mColor;

        public SavedState(Parcelable superState) {
            super(superState);
        }

    }

    要注意的是：必须在布局中为View设置一个唯一的ID，或者在代码中动态设置ID

    否则View的onSaveInstanceState不会被调用，这是因为所有View的状态都是

    被保存在SparseArray数组中的键就是View的ID。
           
6.Android系统中的Handler

  -Handler的作用

  Handler是Android系统中的消息处理机制

  Handler 实现线程之间的通信 主线程与子线程 子线程与子线程之间的通信
  
  Handler 也可以用来实现定时器操作

  -Handler消息处理机制中涉及的对象及其工作原理

  Handler Message MessageQuque Looper 

  MessageQuque 是用来存放消息的  先进先出

  Message 消息对象 消息对象被Handler对象发送，发送到MessageQuque中

  Looper 对象  是一个无限循环 不断的从消息队列中MessageQueue中取出消息Message

  Handler Looper取出消息后，交由Handler进行处理,交由发送该消息的Handler对象处理
  
  对于Handler属于哪个线程  创建Handler时传入的传入的是哪个线程中Looper对象，

  那么Handler就是属于哪个线程, 

  Handler默认的构造方法，无参构造方法中Looper对象是当前线程的Looper对象

  如果是子线程中创建Handler对象，需要手动调用Looper.prepare()方法创建

  Looper对象，一个线程只允许执行一次该方法，因为一个线程只能有一个Looper对象

  然后调用Looper.myLooper()方法可以获取到Looper对象，可以实例化Handler时传进去

  然后调用Looper.loop()方法开启循环，不断的从消息队列中取出消息处理

  -HandlerThread 

   上面说到，在子线程中使用Handler,还需要调用Looper.parpare()方法创建对象 HandlerThread 

   然后实例化Handler时可以Looper.myLooper()获取到Looper对象传入进去，当然也可以

   不传，默认是获取当前线程已经创建好的Looper对象，然后调用Looper.loop()方法开启

   循环读取消息，这样使用起来比较麻烦

   而HandlerThread就是一个线程，并且已经创建好了Looper对象，开启了Looper循环

   HandlerThread handlerThread=new HandlerThread()；
   handlerThread.start()；
   
   Handler handler=new Handler(handlerThread.getLooper())；


   然后通过handle的sendMessage相关的API发送消息去在子线程中执行操作

   这里有个问题，上面我说的是要通过handle的sendMessage相关的API发送消息去在子线程中执行操

   作，一般情况下我们创建一个子线程，都是重写run方法，然后在run方法红执行耗时操作,那我们能

   不能也重写HandlerThread的run方法，在里面执行耗时操作呢,答案是不能

   HandlerThread handlerThread=new HandlerThread(""){
            @Override
            public void run() {
                super.run();
                //如果执行操作 其实是无法执行到的
            }
      

   因为HandlerThread的run方法里面的操作是创建Looper对象，Looper.prepare()

   开启Looper循环 Looper.loop() ，首先我们肯定是要保留HandlerThread里面run方法的操作

   的，但是Looper.loop()是一个无限循环操作，后面的操作都是无法执行的，所以我们在其

   之后操作是无法执行到的。

   注意使用HandlerThread时，如果相关组件被销毁了，我们需要调用handlerThread.quit()

   或者handlerThread的quitSafely()方法来及时的退出子线程中Looper循环，避免造内存泄漏

   quit和quitSafely的区别 实际上HandlerThread的quit和quitSafely方法就是调用Looper的

   quit和quitSafely方法

   quit 是执行了 MessageQueue中的removeAllMessagesLocked(); 清空了MessageQueue中的

   所有消息，包括延迟消息和非延迟消息 

   延迟消息就是指通过sendMessageDelayed或者postDelayed等方法发送的需要延迟执行的消息

   quitSafely 执行的是MessageQueue中的removeAllFutureMessagesLocked方法，清空的只是

   MessageQueue中的延迟消失,而非延迟消息会继续交给Handler进行处理

   -Handler中postDelayed的Message怎么处理?

    Handler的postDelayed以及sendMessageDelay最终都是调用sendMessageAtTime

    方法处理,会通过延迟的时间加上当前时间计算出希望得到处理的时间点,时间点被赋值给
    
    Message的when字段，然后根据希望得到处理的时间，将消息插入到消息队列MessageQueue中;

    Looper的loop方法不断从MessageQueue取出消息，即调用NessageQuqeu的next方法取出一个消息，

    首选判断时间是否已经到达，需要执行的时间点,如果已经到达时间点或者大于时间点，则直接执行，

    否则循环等待，因为MessageQueeu中的next方法是通过循环实现循环等待的；

    这里我们需要注意的一点是，我们调用postDelayed或者sendMessageDelayed方法希望在延迟指定时长之后

    处理我们的消息A，但是如果消息队列中已经有消息，或者在我们发送这个延迟消息后，消息队列中又进来了消息，

    且希望处理的时间点比我们发送的这个需要延迟的消息A时间点要靠前，那么首先肯定是会先处理这些时间点靠前的消息

    如果这些消息的处理是耗时的，那么就有可能导致到达我们的消息在叨叨希望处理的时间点时，还没法处理，也就是实际

    我们调用postDelayed方法和sendMessageDelayed方法并不会一定会在指定的延迟指定时长时之执行，而是可能会在指定时长

    之后执行；

-ThreadLocal

  ThreadLocal是用来在线程中创建局部变量的;

  ThreadLocal的set方法用来存入数据; get方法用来获取保存的数据

  在哪个线程中调用set方法保存数据，只能在哪个线程中get到该数据

  Looper中就使用了ThreadLocal,来保证一个线程对应一个Looper,

  不同的线程中的Looper互不干扰;

7.Parcelable与Serializable
   
  Parcelable与Serializable都是用于实现对象的序列化的
  
  Parcelable是Android中的API，专门设计出来用于Android应用中的数据的序列化的

  Serializable是Java中的API;

  Serializable 会使用反射，序列化和反序列化过程需要大量 I/O 操作， Parcelable 自已实现封送和解封（marshalled 

  &unmarshalled）操作不需要用反射，数据也存放在 Native 内存中，效率要快很多

  如果是应用内数据传输，如果需要传递自定义对象时，对象应该实现Parcelable

  如果是对象数据持久化保存或者是网络对象数据传输，应该使用Serializable

8.SharedPreference
 
  -SharedPreference是Android中提供用来存储数据的一种方式
  
  可以用来存放一些数据量不大的基本类型数据以及String类型的数据

  其本质是将数据存储在xml文件中。

  SharedPreference是一个接口，通过Context的getSharedPreference(String name, int mode)来获取实例

  并且是单例的。

  虽然数据是保存在XML文件中，但是不是每次读取都是从文件中读取的，只有第一次

  是需要加载文件，以后都是从内存中进行读取数据,这样可以提高效率。
  
  -多进程下使用SharedPreference问题

   Context里提供了一个Mode.MODE_MULTI_PROCESS 这种模式用于

   在多进程下使用SharedPreference,如果不使用这种模式，我么可以想一下，

   如果进程A往SharedPreference中存入了一个key-value,

   进程B之前已经获取了SharedPreference实例,这个时候进程B如果

   去读取这个key对应的value,是从内存中去读取的，实际上是获取不到的（如果之前没有存过key），或者

   获取的是旧的数据(如果之前存过key)，因为进程间是不能共享内存的，所以进程A的操作，进程B的内存是不会

   有变化的。

   而Mode.MODE_MULTI_PROCESS这种模式，每次读取都会重新加载一遍文件，不是从内存中读取，

   所以就保证了多进程使用SharedPreference不会出问题。

   但是Android2.3之后，Mode.MODE_MULTI_PROCESS这种模式没废弃了，Google建议多进程数据共享

   使用ContentProvider。

   当然如果觉得使用ContentProvider比较繁琐，我们可以使用腾讯开源的MMKV,

   可以在多进程下安全的使用。

  -MMKV

   基于 mmap(内存映射文件) 的高性能通用 key-value 组件

   MMKV原理:
   
   (1)内存准备

   通过mmap内存映射文件，提供一段可供随时写入的内存块，APP只管往里面写数据
   
   ，由操作系统负责将内存写回到文件，不必担心crash导致数据丢失

   (2)数据组织

   数据序列化方面使用protobuf协议，protobuf在性能和空间上有不错的表现
   
   key限定是 string 字符串类型，value 则多种多样（int/bool/double 

   等）。要做到通用的话，考虑将 value 通过 protobuf 

   协议序列化成统一的内存块（buffer），然后就可以将这些 KV 

   对象序列化到内存中。 

   (3)写入优化

    标准的protobuf不提供增量更新的能力，每次写入都必须全量写入，考虑到主要使用

    场景是频繁的进行写入更新，提供增量更新的能力，将key-value序列化之后，直接

    append到内存末尾，这样同一个key会有新旧若干份数据，最新的数据在最后，那么

    只需要在程序启动第一次打开MMKV时，不断用后读入的value替换之前的值，就可以

    保证数据是最新有效的
   
   (3)空间增长

   使用append实现增量更新带来一个问题，就是不断append的话，文件大小会增长的不

   可控，我们需要在性能和空间上做一个折中，以内存pagesize为单位申请空间，在空

   间用尽之前都是append模式，当append到文件末尾时，进行文件重整，key排重,尝试

   序列化保存排重结果，排重后空间还是不够用的话，将文件扩大一倍，直到空间够用

   9.Android 内存优化之图片内存优化

     -Android中图片的内存优化是非常重要的,因为加载图片往往会导致OOM

     -Android中支持的图片格式： JPEG，PNG，GIF(需要第三方库来显示),WEBP,BMP;

     不论是什么格式的图片，在Android系统中最终都是以位图Bitmap的形式来进行操作
     
     -Android中图片所占的内存大小：

      图片内存大小=图片的宽(像素)*图片的高(像素)*每个像素所占的字节大小

      图片的宽和高也就是图片的大小，每个像素多占的字节大小就是图片的质量

      所以在Android系统中，图片在内存中占用的大小，只与图片的大小和质量有关。

      所以进行图片占用的内存的优化的时候，我们只需要从图片的大小和质量两方面

      来进行考虑。

      (1)缩小图片的大小

      (2)降低图片的质量
       
      -缩小图片的大小

      通过设置BitmapFactory.Option中inSampleSize，可以缩小图片加载到内存中

      的宽和高，inSampleSize设置大于0时，图片的宽和高加载时均会缩小inSampleSize倍

      如：inSampleSize=2，则宽高各缩小2倍，图片占用的内存大小缩小4倍。

      -降低图片的质量

      
      可以通过BitmapFactory.Options中的inPreferredConfig来设置色彩

      模式；

      ARGB_8888:

      Android系统将图片解码成位图时，默认使用的ARGB_8888这种色彩模式，

      每个通道占用8位一共32位，即一个像素占用4个字节(byte)大小，也即32位(

      bit)的内存空间

      ARGB_4444:

      这种色彩模式每个通道占用4位，一共16位，即一个像素占用2个字节大小

      此字段在API级别29中已弃用。由于此配置的质量较差，建议改用ARGB_8888;

      RGB_565：

      R通道占用5位，G通道占用6位，B通道占用5位，一共16位

      即一个像素占用2个字节，只有颜色信息，没有透明度信息

      ALPHA_8:

      Alpha通道，占用8位，一个字节，只有透明度信息，没有颜色信息

      注意：

      但是要注意的是，我们设置指定的色彩模式来解码图片，系统并不一定

      就会使用该种模式来进行解码

      如果inPreferredConfig不为null，解码器会尝试使用此参数指定的颜色模式

      来对图片进行解码，如果inPreferredConfig为null或者在解码时无法满足此

      参数指定的颜色模式，解码器会自动根据原始图片的特征以及当前设备的屏幕位

      深，选取合适的颜色模式来解码，例如，如果图片中包含透明度，那么对该图片

      解码时使用的配置就需要支持透明度，默认会使用ARGB_8888来解码。

      其实大多数情况下非ARGB_8888色彩模式指定都是无效的,具体如下:

      所有情况下ARGB_8888配置都可以满足

      所有情况下ALPHA_8配置都不满足

      绝大多数情况下RGB565选项都不满足

    -除了从图片大小和图片质量两方面来优化之外，对于超大图片的加载
    
     如果我们不想改变图片的大小和质量，我们可以使用BitmapRegionDecoder

     来加载图片的部分区域。

   -BitmapFactory.Options详解
    
    BitmapFactory.Options中各个参数设置，都会影响图片解码成Bitmap的表现，所以很有必要

    了解一下个参数

    (1)inJustDecodeBounds

      设置为true时，解码时，不会将图片加载到内存中，返回的Bitmap为null,使用场景：只希望获取

      Bitmap的宽高，又不会将其加载到内存中 

    (2)inSampleSize

      是用来对图片的宽高进行缩放的,  

   10.Android中Java和JavaScript如何交互？
   
      Android中Java与JS交互是通过WebView来进行交互的;

      所谓交互，也就是：

      -Android调用JS方法

       要想Android可以调用JS的方法，首先WebView得要支持JS
       
       WebSettings webSettings = mWebView.getSettings();
       
       webSettings.setJavaScriptEnabled(true);

       另外必须要设置WebChromClient

        mWebView.setWebChromeClient(new WebChromeClient(){

        });  

        (1)然后使用loadUrl方法执行JS代码

        mWebView.loadUrl("javascript:alert('你好')");

        (2)调用evaluateJavascript方法直接执行JS代码

         mWebView.evaluateJavascript("javascript:alert('你好')", new ValueCallback<String>() {
                @Override
                public void onReceiveValue(String value) {

                }
            });


        特别注意：JS代码调用一定要在 onPageFinished（） 回调之后才能调用，否则不会调用。

      -JS调用Android中的方法

      (1)通过WebView的addJavascriptInterface（）进行对象映射

      -定义一个与JS对象映射关系的Android类：AndroidToJs

      public class AndrodidToJs{

         // 定义JS需要调用的方法
         // 被JS调用的方法必须加入@JavascriptInterface注解

        @JavascriptInterface
        public void hello(String msg) {

        System.out.println("JS调用了Android的hello方法");

        }

      }

      -JS代码

              <!DOCTYPE html>
<html>
   <head>
      <meta charset="utf-8">
      <title>Carson</title>  
      <script>
         
        
         function callAndroid(){
        // 由于对象映射，所以调用test对象等于调用Android映射的对象
            test.hello("js调用了android中的hello方法");
         }
      </script>
   </head>
   <body>
      //点击按钮则调用callAndroid函数
      <button type="button" id="button1" "callAndroid()"></button>
   </body>
</html>

   -Android中通过WebView加载JS
   
         WebSettings webSettings = mWebView.getSettings();

        // 设置与Js交互的权限
        webSettings.setJavaScriptEnabled(true);

        // 通过addJavascriptInterface()将Java对象映射到JS对象
        //参数1：Javascript对象名
        //参数2：Java对象名
        mWebView.addJavascriptInterface(new AndroidtoJs(), "test");//AndroidtoJS类对象映射到js的test对象

        // 加载JS代码
        // 格式规定为:file:///android_asset/文件名.html
        mWebView.loadUrl("file:///android_asset/javascript.html");


      (2)通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url
         
         -拦截Url

         mWebView.setWebViewClient(new WebViewClient() {

            @Override
            public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
                //
                return super.shouldOverrideUrlLoading(view, request);
            }
        }); 

         -解析URL

         -如果检测到是预先约定好的协议，就调用相应方法


-JS端约定协议


         <!DOCTYPE html>
<html>

   <head>
      <meta charset="utf-8">
      <title>Carson_Ho</title>
      
     <script>
         function callAndroid(){
            /*约定的url协议为：js://webview?arg1=111&arg2=222*/
            document.location = "js://webview?arg1=111&arg2=222";
         }
      </script>
</head>

<!-- 点击按钮则调用callAndroid（）方法  -->
   <body>
     <button type="button" id="button1" "callAndroid()">点击调用Android代码</button>
   </body>
</html>
 

 -Android 端拦截解析Url

mWebView.setWebViewClient(new WebViewClient() {
                                      @Override
                                      public boolean shouldOverrideUrlLoading(WebView view, String url) {

                                          // 步骤2：根据协议的参数，判断是否是所需要的url
                                          // 一般根据scheme（协议格式） & authority（协议名）判断（前两个参数）
                                          //假定传入进来的 url = "js://webview?arg1=111&arg2=222"（同时也是约定好的需要拦截的）

                                          Uri uri = Uri.parse(url);                                 
                                          // 如果url的协议 = 预先约定的 js 协议
                                          // 就解析往下解析参数
                                          if ( uri.getScheme().equals("js")) {

                                              // 如果 authority  = 预先约定协议里的 webview，即代表都符合约定的协议
                                              // 所以拦截url,下面JS开始调用Android需要的方法
                                              if (uri.getAuthority().equals("webview")) {

                                                 //  步骤3：
                                                  // 执行JS所需要调用的逻辑
                                                  System.out.println("js调用了Android的方法");
                                                  // 可以在协议上带有参数并传递到Android上
                                                  HashMap<String, String> params = new HashMap<>();
                                                  Set<String> collection = uri.getQueryParameterNames();

                                              }

                                              return true;
                                          }
                                          return super.shouldOverrideUrlLoading(view, url);
                                      }
                                  }
        );
   

      (3)通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt（） 

      消息

  11. Android 热修复

      -AndFix 阿里开源的热修复库  

      HotFix 阿里百川(对HotFix的升级)

      Sophix 阿里手机淘宝团队对HotFix的升级

      都是即时生效的

      -Robust 

       美团的热修复框架

       对每个方法在编译打包阶段自动的插入一段代码,类似代理，将方法执行的代码

       重定向到其他方法；

       实际上使用的是字节码插庄技术

       也是即时生效的

     -Tinker 
      
      介绍Tinker之前，我们先来了解一下 增量更新，全量更新

      我们以APK的版本包为例来说明:

      1.0版本的 APK

      2.0版本的 APK

      全量更新：就是下载2.0版本的APK，安装，以替换1.0版本的APK

      增量更新：首先会有一个差分包，就是2.0版本与1.0版本的不同的地方的一个包

                 然后1.0版本的APK与差分包合成后，就是新的包(相当于2.0的APK的包);

      有一个工具专门用来实现增量更新 bsdiff

      bsdiff支持任意的文件增量更新

      Tinker是腾讯微信团队开发的一款热修复框架;

      Tinker自己开发出了DexDiff,专门比较APK文件中的dex文件的差异，生成dex差分文件

      dex实际上就是字节码文件，都是一个个类的信息，所以Tinker是替换整个类的,

      dex差分包与原本的APK中dex合并生成新的dex,也就是修复之后的dex

      Android中的类加载器:
      
      BootClassLoader 用于加载Android Framework中的类

      PathClassLoader 用于加载自己写的类
 
      DexClassLoader 与PathClassLoader一样，都是加载自己写的类的String   

      -类替换实现热修复的流程：

      要想知道类替换实现热修复的流程，首先得要知道Android中类的加载

      我们修复Bug，肯定是修改自己写的类，而对于自己定义的类，Android中

      是使用PathClassLoader进行加载的;PathClassLoader继承自BaseDexClassLoader

      然后加载某个类的，是调用findClass方法，查找对应的类，是调用BaseDexClassLoader

      中的DexPathList成员的findClass方法，查找类，最终是遍历DexPathList成员中Element[]

      数组查找，Element是DexPathList中的一个内部类，里面又包含DexFile属性，而一个DexFile

      就代表一个dex文件，所以Element对应的是多个dex文件，因为一个dex文件方法数最多是65535

      所以打包APK时经常需要分包，也就是会出现多个dex文件，所以这里是一个Element[]数组，从

      数组中的第一个dex文件开始进行类的查找并进行加载;

      所以我们要想替换类，实际上就会把补丁包dex文件放到Element[]数组的最前面，让PathClassLoader

      先加载补丁包中类，也就是加载修复过的类，原本APK中有问题的类就不会再进行加载了;

      所以类替换实现热修复的步骤是： 

      -获取当前应用的PathClassLoader

      -反射获取到PathClassLoader的父类BaseDexClassLoader中DexPathList属性对象 pathList

      -反射修改pathList的dexElements

       (1)把补丁包的patch.dex转化为Element[]

       (2)获得pathList的dexElements属性(已安装的APK中的dexElements)

       (3)patch+old合并，并反射赋值给pathList的dexElements

     这个类替换的步骤，我们应该是要在Application中的最先执行替换的，所以需要重新

     启动APP，才能够生效的;

     这个基本步骤是没有问题的，但是要注意从Android N开始，Android重新引入了JIT，就是JIT+AOT

     在Android 5.0-Android7.0之间，Android的 ART虚拟机是在应用进行安装的时候将字节码文件

     转机器码，所以应用安装起来很慢；而Android 7.0之后，JIT+AOT 不再安装APK的时候将字节码文件

     全部转成机器码，而是在应用运行的时候，对于一些热点代码，记录到Profile文件中，然后在手机空闲

     或者充电的时候，将对应的热点代码转机器码，生成对应的app image，base.art(类对象映射文件)，这个

     ART文件会在应用启动的时候自动加载，那么根据类加载原理，已经加载过得类是无法再进行加载的，所以我们

     也就无法使用补丁包中类替换原来的类，即无法通过即上面步骤实现热修复；

     对于Android N之后我们到底如何实现热修复；因为我们知道Android N以及之后，会生成base.art这个文件

     这个文件中的类会首先被应用的PathClassLoader进行加载，导致我们无法再进行这些类的替换；

     所以我们可以替换系统的PathClassLoader，使用自己的ClassLoader,这样base.art文件就无效了；
     

12.我们可不可以替换系统中的String类

  -实际上是不能的,因为类的加载的双亲委托机制;会由BootClassLoader加载,无法使用

  自己的类加载器进行加载；   

  -但是如果我们写一个自定义的类加载器,然后重写findClass方法，打破双亲委托机制，也就是

  不调用父类加载器进行加载，可以实现自己重写一个java.lang.String类来替换系统的吗？

  如果我们自己重写一个类加载器重写findClass方法，findClass中我们首先要将Class文件

  转成byte[]，然后需要调用defineClass方法，通过字节码文件byte[]数据获的一个Class

  对象作为findClass方法的返回值；

  我们查看defineClass方法可以知道，最终是调用了defindClass1方法，而defindClass1方法是

  一个native方法，而这个方法就会抛出异常java.lang.SecurityException: Prohibited package name: java.lang

  也就是说使用这个方法来加载我们自己写的类，包名是java.lang实际上是不被允许的；

  所以自定义类加载器实际上也无法加载我们自己写的java.lang.String;
  
13.Hook技术

   Hook技术就是用来干涉程序的运行的；程序在运行的过程中，我们可注入自己的代码

   来执行我们自己的操作；

   -Android中的Hook技术

    (1) 需要Root技术，可以直接Hook系统

    (2) 免Root技术，但是只能Hook自身，无法Hook系统其它APP

  -Hook的步骤
  
   Hook的步骤主要是分为三步

   1.确定要Hook的对象

   (Hook的对象尽量是静态变量或者单例对象，
    
     尽量Hook Public的对象和方法

   )

   2.找到要Hook的对象的持有者，拿到要Hook的对象

   3.定义要Hook的对象的的代理类，并创建该类的对象(这里是静态代理实现)

   4.使用上一步创建的对象，替换掉要Hook的对象
   
  -Hook技术实现的原理：反射和代理

14.Activity的启动流程 

以下是基于Android9.0  (API:28)来分析Activity的启动流程

Activity.startActivity--->Activity.startActivityForResult---->

Instrumentation.execStartActivity--->ActivityManager.getService().startActivity(这里就交到了ActivityManagerService去操作了)

--->ActivityManagerService.startActivityAsUser--->ActivityStarter.execute--->ActivityStarter.startActivity--->

ActivityStarter.startActivityUnchecked--->ActivityStarter.startActivityUnchecked--->

ActivityStackSupervisor.resumeFocusedStackTopActivityLocked--->ActivityStack.executeAppTransition

--->ActivityStack.resumeTopActivityUncheckedLocked--->ActivityStack.resumeTopActivityInnerLocked

--->ActivityStackSupervisor.startSpecificActivityLocked--->ActivityStackSupervisor.realStartActivityLocked

--->

ActivityStarter

ClientLifecycleManager.scheduleTransaction

ClientTransaction.schedule

IApplicationThread.scheduleTransaction 

ActivityThread.scheduleTransaction

ClientTransactionHandler.scheduleTransaction{
   ... 	
   sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);
} 

ActivityThread中  handleMessage

TransactionExecutor.execute 

TransactionExecutor.executeCallbacks

TransactionExecutor.cycleToPath

TransactionExecutor.performLifecycleSequence{
	
    mTransactionHandler.handleLaunchActivity 

}


TransactionHandler中的handleLaunchActivity是抽象方法

TransactionExecutor.performLifecycleSequence中的mTransactionHandler实际上

是ActivityThread,ActivityThread是继承自TransactionHandler;

ActivityThread.handleLaunchActivity

ActivityThread.performLaunchActivity

Instrumentation.callActivityOnCreate

Activity.performCreate{
	
   ....

    onCreate(icicle); //到这里就是执行Activity的onCreate生命周期函数  
}
 
前面的TransactionExecutor.performLifecycleSequence 会根据状态依次执行

mTransactionHandler.handleLaunchActivity 

mTransactionHandler.handleStartActivity

mTransactionHandler.handleResumeActivity

也就是最终对应到Activity中的onCreate,onStart,onResume 

至此整个Activity的启动流程就分析结束了；

15.Android插件化

-插件化技术最初是源于免安装运行APK的想法,这个免安装的APK就可以理解为插件

而支持插件的APP我们一般称之为宿主

-插件化主要是用来解决什么问题?

 (1) APP的功能模块越来越多，体积越来越大

 (2) 模块之间的耦合度高，协同开发沟通成本越来越大

（3）方法数超过65536,APP内存占用过大

-插件化和组件化的区别

 组件化开发就是将一个APP分成多个模块，每个模块都是一个组件，开发的过程中我们可以让这些组件

 相互依赖或者单独调试部分组件等，但是最终发布的时候是将这些组件合并打包成一个APK,这就是组件化开发

 插件化开发和组件化开发的策略不同，插件化开发是将整个APP拆分成多个模块，这些模块包括一个宿主和多个

 插件，每个模块都是一个APK,最终打包的时候宿主APK和插件APK分开打包；

 -插件化实现思路

  如何加载插件的类 

  如何加载插件的资源 

  如何调用插件的类 

-加载插件的普通类 

-如何加载插件的Activity(Android系统四大组件) 

 问题：因为插件的Activity没有在AndroidManifest.xml中注册

 所以要解决的是怎么加载没有在清单文件中注册的Activity?

 这就需要知道Activity的启动流程；

 -组件化
  
  -为什么要使用组件化？

  (1) 随着项目功能模块越来越大，项目的代码越来越庞大，即使分包做的再好，可能

  层次也不是很清晰

  (2)每次修改一点代码，就要重新编译整个项目，编译时间很长

  (3)在团队开发中，也不利于分工，容易导致代码冲突和覆盖等问题

  而组件化一般根据项目的功能将项目分成多个模块，每个模块使用一个Module,

  增加了项目的层次感;

  每个功能模块可以单独编译，加快了编译速度;

  每个开发人员负责自己的模块，避免了代码冲突等问题

  -如何实现组件化？

  要想实现组件化，根据我们上面说的实现组件化的目的，主要要实现以下两点

  (1)首先要保证模块之间可以相互依赖，且每个模块之间可以单独编译; 

  这个我们可以通过gralde配置实现
  
  (2)业务模块之间页面跳转，通信

  -组件化架构

   组件化一般会将一个应用分成这几个模块 

   壳模块:也就是主Module,负责整合各个业务组件，打包APK，没有具体的业务功能

   业务组件模块:根据应用的业务模块 分成多个组件模块

   功能组件模块:对上层提供基础功能服务，如分享

   基础库 ：包含了开源库，以及业务无关的工具库

  -ARoute 实现页面跳转，通信

   -ARoute实现页面跳转

   (1)首先要初始化ARoute: ARouter.init(mApp); 一般放在Application中初始化;

   (2)然后在要跳转的目标Activity中,通过注解配置页面路由路径

   @Route(path="/componedemo/MainActivity")
   
   (3)然后调用ARoute API进行页面跳转
      
       ARouter.getInstance()
              .build("/modulea/ModuleAActivity")
              .navigation();

      如果需要在页面跳转的时候携带数据
      
      ARouter.getInstance()
               .build("/modulea/ModuleAActivity")
               .withInt("num",1)  //携带整形数据 num ,值为1
               .navigation();   
        
      在目标页面需要通过 @Autowired 注解接收参数,并且需要调用  

      ARouter.getInstance().inject(this);注入

      @Autowired(name="num")
      int num   
  
  -模块之间的通信  

   所谓通信也就是 相互发送数据

   Module之间的通信我们可以是方式有：

   广播接受者 :正常使用就可以

   EventBus  :我们需要将定义的Event事件下沉到BaseModule中，主Module和子Module均依赖于BaseModule
              
              然后正常使用EventBus通信即可

   ARouter   :借助于ARouter路由实现组件通信 
   
              因为主Module是依赖于子Module的，所以主Module发送数据到子Module还是很简单的;

              主要要解决的是子Module怎么发送数据到主Module；

              借助于ARouter路由：

              (1) 首先在子Module中定义一个通信接口 ISkill 继承自IProvider
              
              public interface ISkill extends IProvider {
                     void notifyMainActivity(UserBean userBean); //通信方法
              }
               
              (2)然后在主Module定义一个ISkill的实现类  ISkillImpl,并且通过Route注解

              配置路由路径
              
              @Route(path = "/componedemo/ISkillImpl")
               public class ISkillImpl implements ISkill {

                 @Override
                public void notifyMainActivity(UserBean userBean) {
                            //执行操作 
                   }

                 @Override
               public void init(Context context) {

                }

              }

            (3)然后在子Module中调用ARouter API 向子Moudle通信
               ISkill iSkill = ((ISkill) ARouter.getInstance().build("/compone/ISkillImpl").navigation());
               iSkill.notifyMainActivity(new UserBean("2", "李四"));


16.try-catch可以捕获OutOfMemoryError吗

   可以捕获

   try{

      byte[] bytes = new byte[1000 * 1024 * 1024];

   }catch(OutOfMemoryError e){
   
      Log.e(TAG, "outOfMemory: " + e);

   } 

   try-catch 是可以捕获Throwable的，

   OutOfMemoryError 是继承自Error,Error是继承自Throwable的，所以可以捕获；

 17.PackageManagerService

    PackageManagerService 是Android系统核心服务之一,管理着所有跟 package 相关的工作;

    主要功能：

    -解析AndroidManifest.xml

    -

    PackageManagerService是在SystemService进程中启动的

    SystemService.startBootStrapService()--->PackageManagerService.main()

    --->PackageManagerService构造方法实例化PackageManagerService

18.raw与asset目录下的文件有什么不同？
   
   raw下的文件，会在R.java中生成对应的ID,我们可以通过ID访问,raw可以在XML中访问
   
   asset目录下的文件不会生成id，只能通过getAsset访问，不可以在XML中访问

19.Application与Activity的对应的上下文对象是一样的吗?

   Application对应的Context的生命周期是整个应用的生命周期

   Activity对应的Context的生命周期是Activity从创建到销毁

20.如何判断一个App是在前台还是现在后台?

可以在Application中registerLifecyleCallBacks注册Activity的生命周期

回调函数，定义一个变量mActivityCount;，然后分别在onActivityStart和onActivityStop中；

mActivtiy++,mActivity--;，如果mActivity大于0则APP处于前台，否则处于后台；

21.Android 进程间通信 IPC(InterProcess-Communication)

-Android多进程 (为什么APP要使用多进程？)

一般情况下，一个应用只有一个进程，但是在APP功能模块越来越多，业务

越来越复杂的情况下，APP对运行内存的使用也越来越多，而单个进程所分配

到的运行内存是有限的，所以我们可以为我们的应用用上多进程，让一部分的

组件运行在其他进程，以降低APP的内存压力；

(1)缓解APP的内存压力，降低OOM的可能性

(2)增加应用的稳定性，某个进程出现崩溃，不会影响主进程，而导致

   整个应用闪退；

-怎么实现多进程？

怎么实现多进程这个问题，这里实际上涉及到的是两个问题

(1)怎么让我们的APP运行在多个进程? 如何开启多进程

(2)运行在多个进程，不同进程之间的组件怎么通信?  进程间通信 IPC 

-让APP运行在多进程，实际上就是让应用的一部分组件运行在其它进程

 只要在AndroidManifest.xml中声明组件时，为组件设置android:process

 属性 android:process=":other",这样组件就运行在了其它进程;

 android:process属性的值

 -以":"开头 如android:process":other",这样设置，进程名为

  应用包名:other,创建的进程属于当前应用的私有进程，其它应用的

  组件不可以和它跑在同一个进程中

 -不以":开头" 如:android:process="com.myactivity.otherprocess"
 
 这样设置，进程名就为设置的属性值com.myactivity.otherprocess,

 创建的进程属于全局进程，其它应用可以通过shareUID方式和它跑在同一个

 进程中;

 Android会为每一个应用分配唯一的一个UID(linux user 

 ID),则这样权限就被设置成该应用程序的文件只对该用户可见，也就是只对

 该应用程序自身可见，而我们可以使某个应用程序的文件对其它应用可见，这就会

 使用到shareUID,就是让两个APK有相同的UID,这样它们就可以看到对方的文件

 两个应用通过shareUID运行在同一个进程中是有要求的，就是急需要两个应用

 有相同的UID，并且签名也要相同；

-多进程产生的问题

不同的进程间，有不同的虚拟机实例，不同的虚拟机实例对应的是

不同地址的内存空间，这就导致在不同进程中访问同一个类的对象，会

产生多个副本，所以不同进程之间数据不是共享的;

(1)Application会创建多个实例，初始化多次
   
   我们通常会在Application的onCreate中进行一些初始化操作，主要是

   第三方SDK的初始化等，那么这些初始化操作我们只需要在主进程初始化

   一次就可以了，但是由于Application会初始化多次，导致这些初始化操作

   执行多次；

   解决办法：判断是否是主进程，只有主进程的时候才执行相关的初始化操作；

(2)静态属性不可共用

在单进程下，类的静态属性在所有地方是共享的，即在某个地方进行修改，其它

地方访问时，肯定是修改后的值，但是在多进程下不是这样,因为多进程不是内存

数据共享的;

单例和同步锁也是同样失效的;

(3)单例以及同步锁都失效

也是由于数据不共享的原因，导致单例和同步锁失效

(3)文件共享失效

   多进程情况下，会出现两个进程在同一时刻访问同一个数据库文件的情况

   这可能造成资源的竞争访问，导致数据库损坏，数据丢失等；在多线程情况下

   我们可以通过锁机制来控制资源共享，但是多进程下锁机制也是无效的；

   解决办法：就是多进程的时候不访问同一个文件，比如子进程涉及到数据库

   操作，就可以考虑调用主进程进行数据库的操作；

-进程间通信

 (1) BroadCastReceiver

 (2) ContentProvider

 (3) Binder

 (4) Socket

-Binder实现进程通信的原理
 
 在学习Binder进程通信原理之前，我们先来了解一下进程间通信;

 首先为什么进程之间不是内存共享的？

 Android系统的内核是Linux，而在Linux中一个进程是被分为用户空间

 和内核空间，不同的进程都有自己的用户空间，而内核空间只有一个；

 用户空间之间的数据是不共享的，而内核空间只有一个，所有进程共享

 一个内核空间，所以内核空间的数据是共享的;

 而应用的不同进程中的数据是在各自的用户空间中的，所以是不共享的；

 由于内核空间是数据共享的，所以进程之间需要通信，肯定是需要借助于

 内核空间；

 一般的实现进程间通信都是发送数据的进程先把数据拷贝到内核空间中，然后

 再从内核空间中把数据拷贝到接收进程中，涉及到两次数据拷贝;

 而Binder通信机制是Android开发出来的一套实现高效的进程间通信的机制,

 Binder通信机制的原理是MMAP(内存映射)，而MMAP就是将内核空间的一段内存

 区域映射到用户空间，用户对这段内存区域的修改会直接反映到内核空间，相反

 对内核空间的这段内存区域的修改也会直接反映到用户空间；

 并且可以将内核空间的这段内存区域映射到多个进程的用户空间，这样就可以实现

 多个进程之间的数据共享，也就是实现多个进程之间的通信;Binder通信只会涉及到

 一次数据拷贝；

 而在Android 中AIDL就是实现Binder通信的一种方式
  
 -AIDL
  
 AIDL(AndroidInterface Define Language)

 我们知道Android中进程间通信的方式是Binder,而我们如果通过Binder的方式来实现

 进程通信，那就需要按照Binder的规则来实现，可能稍微有点麻烦；

 而AIDL就是帮我们简化实现Binder通信的，所以说是实现Binder通信的一种方式
 
 -使用AIDL的流程
  
  (1)创建AIDL文件

     首先我们在Android Studio中将项目切换到Project视图，然后在

     app/src/main目录下右键新建一个AIDL文件，新建AIDL文件之后

     会发现main下会自动生成一个aidl目录 aidl/应用包名/aidl文件

     这个AIDL文件中，实际上就是一个接口，当我们重新编译一下项目之后，
     
     在app/build/generated下就会生成一个aidl_source_output_dir目录

     而这个目录就是我们编写的AIDL文件对应的JAVA接口文件;

     而我们编写的AIDL接口文件中，我们需要写的是我们通信的方法；
  
  (2)服务端 创建Service,并且在Service中通过AIDL文件自动生成的JAVA接口

     创建IBinder对象,实现我们之前定义的通信方法；在Service的onBind方法中返回这个

     IBinder对象;

     private IBinder mIBinder = new IMyAidlInterface.Stub() {
        @Override
        public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException {

        }

        @Override
        public void addUser(UserBean userBean) throws RemoteException {

        }

        @Override
        public int getNum() throws RemoteException {
            return mNum;
        }
    };

  (3)客户端 绑定上面定义的这个Service，在onServiceConnection中

     通过AIDL接口文件生成的JAVA接口文件已经Service中传过来的IBinder

     对象生成这个JAVA接口对象 ，然后通过这个Java接口对象就能够调用其中

     的我们缩写的通信方法进行通信;

     但是很明显客户端拿到AIDL Java接口对象方法，是客户端主动向服务端发起通信，

     如果服务端要主动向客户端发起通信怎么办?

     我们可以通过使用观察者模式，在AIDL文件中写一个方法向Service中添加一个回调接口，

     再写一个取消回调接口的方法;

     客户端在绑定Service，成功连接也就是ServiceConnection的onServiceConnection的

     回调中调用AIDL对应JAVA接口中的向服务端添加回调的接口

     这样Service中也就是服务端如果希望主动向客户端发起通信，就可以通过这个回调接口

     对象调用回调方法，从而主动向客户端发起通信;

  -AIDL支持的数据类型
  
   基本数据类型，int、long、boolean、float、double

   String类型

   CharSequence

   自定义类类型 需要实现Parcelable接口

  -in、out、inout 

22. try-catch可以捕获OutOfMemoryError吗

   可以捕获

   try{

      byte[] bytes = new byte[1000 * 1024 * 1024];

   }catch(OutOfMemoryError e){
   
      Log.e(TAG, "outOfMemory: " + e);

   } 

   try-catch 是可以捕获Throwable的，

   OutOfMemoryError 是继承自Error,Error是继承自Throwable的，所以可以捕获；

23.Android 事件分发机制

   dispatchTouchEvent

   onInterceptTouchEvent

  首先是由父View接收到触摸事件,也就是ViewGroup接收到触摸事件
  
  进入到dispatchTouchEvent方法--->onInterceptTouchEvent

  如果onInterceptTouchEvent返回false,则表示当前ViewGroup

  不拦截该事件，交由子View进行处理，子View进入dispatchTouchEvent

  方法,子View如果是ViewGroup继续执行上述流程，如果不是ViewGroup则

  执行onTouchEvent方法，onTouchEvent返回true，表示该子View处理完当前事件，事件结束；

  如果返回false,表示子View无法处理再交由父View进行处理；

  如果父容器ViewGrop拦截了子View的事件，也即onInterceptTouchEvent返回true,

  我们如果在无法修改ViewGroup源码的情况下，我们又希望某个子View不被ViewGroup拦截

  事件,我们可以在子View的dispatchTouchEvent,onInterceptTouchEvent,onTouchEvent中调用父View的

  requestDisallowInterceptTouchEvent(true)，来告诉父View不要拦截事件； 

  这是View事件分发的的大致流程；

  -我们再来看下View中一些比较常见的触摸方法和监听

    onTouchEvent方法，mOnTouchListener,onClickListener

   我们通过View的dispatchTouchEvent方法来看一下上述执行的流程

   如果mOnTouchListenre不为null,并且mOnTouchListener的回调

   方法onTouch方法返回true，表示事件已处理完，如果onTouch返回false

   --->onTouchEvent返回true表示事件已处理完，否则再交由父View;

    setOnClickListener是在onTouchEvent中调用的，所以如果设置了

    mOnTouchListener,并且回调方法onTouch返回true,则不会走onTouchEvent,

    setOnCliclListenre也无效了;

24.Android 签名机制

   -应用签名

    我们在开发完应用之后，需要生成一个用签名文件签名之后的APK文件,然后才能发布;

    那为什么要对应用进行签名？

    我们知道Android系统唯一识别一个应用的标识是应用的包名; 那么如果有另外应用和我们

    的应用的包名一样，那么安装这个应用的时候就会覆盖我们的应用，所以仅仅通过包名还不过，

    Android系统还会检测APK的签名是否一致，如果安装应用的时候发现和已安装的某个应用的包名

    一致，但是签名不一致，是无法进行安装的;

    并且签名机制，也能够防止我们的APK文件被别人二次打包；

   -应用的签名过程

    我们对打包出来的APK文件，修改后缀名为.zip之后，进行解压，解压出来之后，有一个MEAT_INF

    目录，这个目录下有三个文件MANIFEST.MF,CERT.SF,CERT.RSA文件； 这三个文件都是应用签名

    相关的文件;

    (1)MANIFEST.MF文件中的内容 是对APK中的所有文件使用信息摘要算法（SHA算法）生成的信息摘要的base64值

    (2)CERT.SF文件 首先是MANIFEST.MF文件使用信息摘要算法生成信息摘的base64要作为头部属性，然后其他内容

    是MANIFEST.MF中的每一项再单独使用信息摘要算法生成的摘要的base64值;    
    
    (3)CERT.RSA文件中的内容  是CERT.SF文件进行数字签名(也就是使用私钥对CERT.SF中的内容进行加密)，

    以及数字证书的一些信息，包括公钥信息;

   -应用安装的时候前签名校验的过程

    根据应用的签名的过程，我们应该就知道Android系统在安装APK的时候是怎么进行签名校验的，无非

    就是将应用的签名过程再走一边，然后与META-INF中的三个签名相关关的文件中的内容做比对，来校

    验签名

    依次来判断是否可以安装应用;

    校验的步骤：

    (1)首先将APK中的所有文件(除了META_INF下的文件),使用信息摘要算法生成信息摘要的base64值，

    然后与MANIFEST.MF中的内容做比对，如果一致进行下一步，否则校验失败； 

    (2)然后将MANIFEST.MF文件生成信息摘要，以及MANIFEST.MF中的单独每一项生成信息摘要与

       CERT.SF中的内容做比对，如果一致进行下一步，否则校验失败； 

    (3)对CERT.SF中的内容生成数字签名以及数字证书的信息包括公钥和CERT.RSA中对应的信息进行

       比对，如果一致则校验成功，否则校验失败；   

    如果你修改了APK中的某一个文件，那么更改的文件生成的信息摘要，肯定与MANIFEST.MF中的

    该文件的信息摘要不一致，验证失败，如果你对更改后的文件生成信息摘要，然后同时修改MANIFEST.MF

    中对应的属性值，那么与CERT.SF中的摘要值不一致，照样验证失败，如果你还不死心，也修改了CER

    T.SF中的摘要值，那么数字签名值必定与CERT.RAS中的不一样，因为数字签名是使用私钥签名的，私

    钥只有应用的发布者知道,所以还是会校验失败； 这样Android中的签名机制成功防止了二次打包；

    -Android中的V1,V2,V3签名

     -V1签名机制的缺点：

     (1)我们知道META_INF目录下存放的签名相关的文件是不会在签名校验时使用到，所以我们可以在在MET

     A_INF目录下添加文件，这样就可以破坏APK文件的完整性，如一些批量打包方案就是在META_INF目

     录下添加空文件实现的；

     (2)由于V1签名，校验时需要对所有文件生成信息摘要进行比较，比较耗时，导致应用安装比较慢

     -V2签名机制

     正是由于V1签名机制的一些缺陷，所以出现了V2签名机制，首先V2签名机制，不再是对APK文件中单个

     条目进行进行验证，而是验证整个APK文件的字节，所以速度要比V1要快；

     V2签名模式中在原先的APK块中增加了一个新的签名块，签名块存储了签名，信息摘要，签名算法

     证书链等信息;

     为了保护APK内容，整个APK被分为4个区块：

     ZIP条目的内容(也就是数据区，是一个记录列表，每条记录包含文件名，压缩前后大小，压缩后的数据) 

     APK签名块 (存放签名，签名算法，信息摘要，证书信息)

     ZIP中央目录 (

     也是一个记录列表，每条记录存放的文件名，本地文件头起始偏移量,通过本地文件头的起始偏移量

     可以找到文件压缩后的数据
     )

     ZIP中央目录结尾（中央目录的条目数,size,起始偏移量）

     -V2签名过程

      首先把APK中ZIP条目内容，ZIP中央目录，以及ZIP中央目录结尾按照1M大小分成一些小块

      生成每个小块的信息摘要

      然后通过这些小块的信息摘要整体再生成一个信息摘要也就是APK摘要；

      然后使用签名文件中的私钥对APK摘要进行加密，加密后的数据也就是签名

      签名、APK摘要、签名算法、证书都会被放到签名块中；

    -V2签名校验过程
    
     V2签名机制是从 Android 7.0(Android N)开始引入的，所以只有Android 7.0以上的设备上才可以安装V2签名的APK包

     Android 7.0以下的包无法安装只用V2签名模式签名的包；V1签名的包可以安装在Android 7.0之前设备，也可以安装在

     Android 7.0之后的设备，只不过V1签名的包在Android 7.0之上不会使用安全的验证模式;

     当然我们还可以同时使用V1和V2两种签名模式对APK进行签名,可以在Android 7.0之前和之后的设备上安装，并且在

     Android 7.0之上安装时使用安全的验证模式;
     
     签名校验过程：

     在Android7.0以上的系统在安装APK的时候，首先会检测APK中是否有V2签名块，如果有V2签名块,则验证是否符合

     V2签名，也就是验证APK摘要，以及是否解密出签名数据等；

     如果没有V2签名块，则降级为V1签名验证，执行V1签名验证过程;

    -反编译 apktool

     apktool d test.apk  //反编译APK文件,生成test文件夹，里面是反编译出的APK内容

     apktool b test -o sign.apk 
     //重新对反编译出的APK文件内容 打包回APK 

    -jarsigner 对APK重新签名

     jarsigner -verbose -keystore [keystorePath] -signedjar [apkOut] [apkin] [alias]

命令格式及参数意义：

-verbose -> 输出签名过程的详细信息

-keystore [keystorePath] -> 密钥的库的位置

-signedjar [apkOut] -> 签名后的输出文件名

[apkin] -> 待签名的文件名

[alias] -> 证书别名

这里最好是把要签名的APK移至签名文件同目录下，这样就不用写签名文件的完整路径

例子：(这里待签名文件test.apk是在签名文件nadoinc.jks同目录下)

jarsigner -verbose -keystore nadoinc.jks -signedjar sign.apk 

test.apk nadoinc

25.中间人攻击

   -即在通信双方中间监听网络数据以便获取有价值的信息实现攻击破坏；

    具体实现是在客户端与服务器之间进行网络通信时，中间人监听并劫持了请求，

    然后伪装成客户端与服务器端进行通信，将服务器端的响应再返回给客户端，伪装

    服务器与客户端进行通信；

   -使用抓包工具Charies模拟中间人攻击

   -如何防止中间人攻击 

    我们在使用Https的安全请求时，能够被中间人攻击的一个主要原因是我们没有对服务器端的证书

    以及域名做校验，导致中间人有机可乘;

    一般情况下，我们都没有做任何证书校验，使用网络框架自身的Https校验，实际也就是只要系统内置

    的受信任的证书的网站都是可以访问的，不是系统受信任的证书的网站都是无法访问的，如果一些是非

    知名证书机构颁发的证书的网站就是无法访问的;

    但是这样默认的校验方式，不能抵御中间人将自己的证书安装到设备上来进行中间人攻击;

    所以我们需要在应用中校验服务端的证书，只对我们指定的证书信任;

24.APK打包流程

   我们知道Android移动设备上的一个应用是安装的APK文件，而一个APK

   文件就是一个Android项目源码编译打包之后的产物;

   在了解Android打包流程之前,我们先看一下打包的产物APK文件是一个什么样的

   结构；

   我们知道APK文件实际上是一个压缩文件，我们解压出来之后就可以查看APK文件的结构

   classes.dex文件 : 是Java代码编译之后的class文件通过Android SDK目录中build-tools

                    中dex.bat转成classes.dex文件;  .dex文件是Dalvik或者ART虚拟机

                    加载并执行的文件;

   lib目录: lib目录中存放的是项目使用到的.so文件

   res目录: res目录中保存的是处理后的二进制资源文件

            如图片资源文件，布局资源文件，颜色资源文件等
   
   resources.arsc文件:编译后的二进制资源文件索引，记录了资源文件

                      和资源文件ID的映射关系，这样程序在运行的过程中

                      就可以根据资源ID找到对应的资源文件了；                  

   AndroidManifest.xml文件：AndroidManifest.xml文件是Android应用的配置文件

                            这里是编译之后的二进制文件

  -APK的打包流程
  
   了解APK文件的结构，现在我们再学习一下APK文件打包流程;

   (1)使用AAPT/AAPT2编译资源文件生成resources.arsc以及R.java文件;

      (打包资源工具AAPT位于android-sdk/platform-tools目录下)

   (2)使用aidl工具处理AIDL文件，生成java文件

      (aidl工具位于android-sdk/platform-toold目录下)

   (3)编译Java源文件，生成.class文件

      (使用Java编译器javac编译java源码键生成.class文件，生成的.class文件位于

      app/build/intermediates/javac/debug/classes目录下

      )

   (4)通过dx工具将.class文件转成.dex文件，可以在Dalvik和ARTAndroid虚拟机上执行

      (dx工具位于android-sdk/build-tools/Android版本目录下/dex.bat)

   (5)使用Android NDK处理native代码生成.so文件

   (6)使用apkbuilder工具打包生成未签名的APK文件

      apkbuilder原本为一个脚本文件,原本存在与android-sdk/tools目录下，现在已经被移除了

      ，使用android-sdk/tools/sdklib-26.0.0.jar

      文件中com.android.sdklib.build.ApkBuilder这个类来进行文件打包

   (7)签名APK

     将上一步打包好的APK文件使用签名工具apksinger以及签名文件进行签名，签名后的APK文件就可以安装了

     签名工具路径 android-sdk/build-tools/android版本/apksigner.bat

25.Android UI的刷新机制/屏幕的刷新机制/UI的绘制原理

   View--->ViewGroup--->ViewRootImpl

   View.invalidate()--->View.invalidate(true)--->View.invalidateInternal()

   --->ViewGroup.invalidateChild()--->ViewGroup.onDescendantInvalidated()

   --->ViewRootImpl.onDescendantInvalidated()--->ViewRootImpl.invalidate()

   --->ViewRootImpl.scheduleTraversals()--->ViewRootImpl.doTraversal()

   --->ViewRootImpl.e()--->ViewRootImpl.performMeasure()

                           ViewRootImpl.performLaout()

                           ViewRootImpl.perfromDraw()

   --->ViewRootImpl.draw()

26. gradle 中 implementation ,api ,compile 的使用与区别

27.RecycleView的回收复用机制

   一级缓存： mAttachScraps/(mUnmodifiableAttachedScrap)  

             mChangedScrpas

    一级缓存mAttachScraps,mChangedViews 缓存的都是屏幕内的item的ViewHolder
    
    mAttachScrpas缓存的是屏幕内数据没有改变的item的ViewHolder

    mChangedScraps缓存的是屏幕内的数据发生改变的item的ViewHolder

   二级缓存: mCacheViews  

   mCacheViews缓存的是移出屏幕外的item的ViewHolder        
  
   三级缓存:  ViewCacheExtension

   使用户可以自定义item的ViewHolder的缓存和创建

   四级缓存： RecyclerPool   

   mCacheViews中默认容量是2，当然可以设置容量；但是不管容量多少，如果

   mCacheViews中已满，则再有item中ViewHolder来时，mCacheViews中按照先进先出FIFO
   
   移出先进的ViewHolder，把新来的放进去，而移出的ViewHolder会被放进RecyclerPool中,

   RecyclerPool是通过SparseArray根据布局类型type存放ViewHolder;也即SparseArray是以

   布局类型type为键，值为ScrpData,而ScrpData中维护了一个ArrayList<ViewHolder>数组

28.Android屏幕适配

   -什么是屏幕适配？

    Android系统的设备有很多种，碎片化很严重，所以屏幕的尺寸，分辨率等都会有很大差异，

    那如何保证我们编写的UI布局，可以在不同尺寸，分辨率的设备上较好的显示，这个就涉及到

    屏幕适配； 

    在没有一些好的适配方案之前，我们通常所能做的就是,在布局中尽量不要使用绝对布局，控件的

    宽高尽量使用wrap_content,和match_parent,使用layout_weight这样的权重属性，这样的一些

    基本用法可以使我们的布局更好的适配不同的设备;

  -屏幕适配中的一些基本概念
  
   我们在开发过程中，布局中我们会使用dp来作为宽高的单位，那dp是什么呢？

   dp也叫dip 是设备无关像素，不论布局中使用什么单位，最后都要被转成对应的px,

   所谓设备无关像素，即最终在不同的设备上看起来的长度基本是一样的;

   那dp是如何转成px的呢？
   
   dp转px的公式为：

   px=value * displayMetrics.density  (value为dp的值)

   而displayMetrics.density=densityDpi/160

   而densityDpi是屏幕密度dpi,所以dp转px，是与屏幕密度dpi有关的

   -屏幕密度 系统密度与实际密度

   dpi就是屏幕密度，是指每英寸上的像素点数，dpi是软件概念上的屏幕密度，

   还有一个ppi，是物理上的屏幕密度，dpi是人为指定的，软件上的屏幕密度

   一般会参考物理的屏幕密度，然后人为指定；像Android系统，就将碎片化的

   Android设备根据屏幕密度，也就是显示级别分为几类屏幕密度的设备，分别是

   120、160、240、320、480、640；这些就是人为指定的dpi,这个屏幕密度在手机生产时

   就被指定了;也就是系统密度 
   
   系统密度可以这样获取：

   DisplayMetrics displayMetrics = getResources().getDisplayMetrics();

   int densityDpi = displayMetrics.densityDpi;//屏幕密度dpi

   实际密度：

   而设备的真正的屏幕密度，也就是实际密度，是应该通过计算出来的；

   根据屏幕密度的定义，应该是每英寸屏幕的像素点数

   根据屏幕的像素宽和像素高，可以计算出屏幕对角线的像素，再根据屏幕尺寸，

   计算出对角线上没英寸多少像素，也就是实际的屏幕密度；

   在碎片化的众多Android设备中，一部分会根据实际的屏幕密度，然后取一个上面几类的

   密度中最接近实际屏幕密度的一个作为系统屏幕密度，这样获取到的displayMetrics.densityDpi

   也就是这个值；

   但是现在也有许多手机就是以实际屏幕密度作为系统屏幕密度；而选择drawable目录时，是选择最为

   接近这个实际屏幕密度的drawable目录使用

   dpi屏幕密度既然是指每英寸上的像素点数，那么屏幕密度越大，则显示也就更细腻;

   这些设定的dpi，也对应着drawable的相应目录：

    ldpi   dpi范围  0-120   

    mdpi   dpi范围  120-160

    hdpi   dpi范围  160-240

    xhdpi  dpi范围  240-320

    xxhdpi dpi范围  320-480 

    xxxhdpi dpi范围 480-640
 
    而上面的dp转px计算公式中value * displayMetrics.density
    
    displayMetrics.density=densityDpi/160;

    px=value*densityDpi/160 这里除以160，是以160dpi屏幕密度的设备为基准

    也即：在屏幕密度dpi为160的设备上，1dp=1px

    那么我们平时开发中,图片资源放到不同的drawable目录，实际上图片在内存中的宽和高是不一样的

    ，图片的大小会进行缩放，所占用的内存也是不一样的;

    缩放的比例为inTargetDensity/inDensity，

    inTargetDensity是目标像素密度，也就是手机本身的屏幕密度;

    inDensity是图片实际所放的目录dpi;

    比如如果手机的屏幕密度是480dpi，所以图片本来应该放在xxhdpi-drawable目录中，而

    如果图片实际被放在了drawable-xhdpi目录中，也就是320dpi目录，那么图片实际缩放

    比例为480dpi/320dpi=1.5,也就是会被放大1.5倍,图片看起来也就是会失帧，所占内存

    也会越大

    所以从ldpi到xxxhdpi目录，同一张图片所占内存实际上是越来越大的;

    所以如果在实际开发中，如果我们只切一套图，我们应该放在xxhdpi或者xxxhdpi目录中，

    因为所占内存要小；

   -屏幕尺寸

    屏幕尺寸就是物理屏幕尺寸，指屏幕对角线的长度，单位是英寸； 1 inch=2.54cm

    "5寸大屏手机"，就是指对角线的尺寸，5*2.54=12.7cm

   -屏幕分辨率
    
    屏幕的分辨率就是指屏幕图像的精密度，也就是指屏幕或者显示器所能显示的像素点数

    一般就是以屏幕横向像素*屏幕纵向像素 来表述  如：1080*1920

    -总结：

    1、同一张图片，放在不同目录下，会生成不同大小的Bitmap。Bitmap的长度和宽度越大，占用的内

    存就越大。

    2、同一张图片，放在不同的drawable目录下（从drawable-lpdi到drawable-xxhpdi）在同一手机

    上占用的内存越来越小。

    3、图片在硬盘上占用的大小，与在内存中占用的大小完全不一样。

29.ListView加载图片错乱怎么处理?

   -ListView在什么情况下会出现加载图片错乱的问题?
    
    ListView在中的Item在异步加载图片的情况下会出现错乱;

    ListView 异步加载图片之所以会出现错乱，是因为ListView的缓存机制导致的；

    ListView之所以可以加载成千上万条数据而不出现OOM，就是因为ListView的缓存机制

    ListView会将滑出屏幕之外的View进行复用，但向上滑动时，下方新的Item会复用上面

    移出屏幕外的View；

    所以当Item加载网络图片时，如果某个Item加载网络图片还没有加载完就被滑出屏幕了，

    滑出屏幕之后加载好了，那么下面新的View进入屏幕时，可能会复用这个Item的View，

    而这个新的Item也会异步加载网络图片，当这个新的Item的图片没有加载好之前，显示的

    会是复用的这个View的图片，所以就会出现图片错乱的问题；

    那么当新的Item的图片加载好之后，又会显示这个新的图片，所以会导致闪烁问题;

    解决办法：我们给在getView方法中可以给显示图片的控件如ImageView 

    设置一个tag,tag是图片的url或者position，tag可以唯一标识数据就可以，在异步下载

    图片成功之后，显示到ImageView上之前，先判断ImageView中的tag值和我们下载的这个图片的

    url或者position是否是一致的，一致的才显示到ImageView上，不一致则不作显示的操作;

30.为什么NestedScrollView可以解决ScrollView嵌套RecycleView的滑动冲突问题？
   
   -首先我们来分析一下滑动冲突的根本原因？ 

   要么是父View拦截了子View的事件，使得子View无法响应事件

   要么是子View消费了事件，使得父View无法处理事件

   要解决嵌套滑动实际上就是要确定，什么时候应该交由父View处理，什么时候应该交由子View处理

   滑动事件；

   我们解决嵌套滑动冲突也是从这个思路入手就可以了；

   而Android 5.0(API 21)开始，Android提供了嵌套滑动的官方支持方案，就是NestedScroll嵌套滑动

   机制，而嵌套滑动机制的原理就是:

   嵌套滑动的基本原理是在子控件接收到滑动一段距离的请求时, 先询问父控件是否要滑动, 如果滑动了父控件就通知子控件它消耗了一部分滑动距离, 

   子控件就只处理剩下的滑动距离, 然后子控件滑动完毕后再把剩余的滑动距离传给父控件.

   通过这样的嵌套滑动机制, 在一次滑动操作过程中

   父控件和子控件都有机会对滑动操作作出响应, 尤其父控件能够分别在子控件处理滑动距离之前和之后对滑动距离进行响应.

   Android5.0之后的ViewGroup和View中增加了处理嵌套滑动的相关方法，只要我们可滑动的ViewGroup和View分别继承自

   View或者ViewGroup，然后在事件监听中 onTouchEvent调用相应方法子View把事件交由父View处理，父View中在处理了之后

   剩下的距离再交由子View处理;

   Android还提供了5.0之前的兼容方案，只要父View和子View两个可滑动的View分别实现NestedScrollingParent和

   NestedScrollingChild,并且在相应的实现方法中调用NestedScrollParentHelper和NestedScrollChildHelper

   进行处理即可;

   NestedScrollView 和RecycleView 分别是实现了NestedScrollingParent和NestedScrollingChild

   所以是支持嵌套滑动的，所以就不会出现冲突;

31.Android代码混淆
   
   所谓代码混淆就是使用Proguard这个Java代码混淆器对Java中的代码进行混淆；

   Java源代码编译之后的字节码文件中，类名、方法和属性还是具有一定语义的很容

   易被反编译者知道代码的逻辑；

   所以可以通过混淆器对字节码文件中的类名，方法和属性使用一些无意义的符号进行命名

   比如a,b,c这些;

   Proguard除了能够对字节码中的类名，方法，属性名进行重新命名，还能够移除没有使用,

   优化字节码

   的类，方法，属性；

   所以混淆除了能够保护代码之外，还能够对代码进行压缩，优化APK大小 

   我们在build.gradle中配置minifyEnable true,在默认的混淆文件proguard-rules.pro

   编写混淆规则即可；

   混淆文件中要配置的实际上就是要告诉混淆器哪些东西不能够混淆的

   Java的反射，为什么不能混淆呢？因为代码混淆，类名、方法名、属性名都改变了，而反射它还是按照

   原来的名字去反射，结果只射出一个程序崩溃
   
   注解用了反射，所以不能混淆。 

   不混淆任何包含native方法的类的类名以及native方法名，否则找不到本地方法。

   四大组件不能混淆，因为AndroidManifest.xml文件中是完整的名字

   自定义view也是带了包名写在xml布局中，不能混淆; 

32.Retrofit 所有的请求都有一个Token参数 ，这个时候这个Token怎么添加

   通过添加拦截器的方式，在拦截器的intercept方法里面进行Token的添加

   操作;

   那如何解决Token过期，自动刷新Token重新请求呢?

   也是通过添加拦截器，在拦截器方法里面先执行请求，返回的如果是

   Token失效，则获取新新的Token,用新的Token创建新的请求再请求一次

   public class TokenInterceptor implements Interceptor {

    @Override
    public Response intercept(Chain chain) throws IOException {

        Request originalRequest = chain.request();
        Response response = chain.proceed(originalRequest);

        try {
            ResponseBody responseBody = response.body();
            //解决response.body().string();只能打印一次
            BufferedSource source = responseBody.source();
            source.request(Long.MAX_VALUE); // Buffer the entire body.
            Buffer buffer = source.buffer();
            Charset UTF8 = Charset.forName("UTF-8");
            String string = buffer.clone().readString(UTF8);

            BaseResponseBean baseResponseBean = new Gson().fromJson(string, BaseResponseBean.class);
            if (baseResponseBean != null) {
                if (baseResponseBean.getCode().equals(ResponseCode.TOKEN_ERROR)) {
                    //token过期
                    //根据RefreshToken同步请求，获取最新的Token
                    String newToken = getNewToken();

                    //使用新的Token，创建新的请求
                    Request newRequest = chain.request()
                            .newBuilder()
                            .header("authToken", newToken)
                            .build();
                    //重新请求
                    return chain.proceed(newRequest);
                } else if (baseResponseBean.getCode().equals(ResponseCode.REFRESH_TOKEN_ERROR)) {
                    //refreshToken过期
                    EventBus.getDefault().post(new Handler(Looper.getMainLooper()).obtainMessage(Constants
                            .Key_EventBus_Msg.EVENT_TOKEN_OVERDUE));
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return response;
    }

33.渐进式加载图片

    -JPEG

    Base-Line  基本的JPEG

    Progressive 渐进式加载JPEG

34.Only the original thread that created a view hierarchy can touch its views. 

   只有创建了view树的线程，才能访问它的子view  

   我么通常都说子线程中不能更新UI，实际上是不准确的，应该是只有创建子View树(ViewRootImpl)的线程才能更新它的子View

   如果我们在子线程中创建UI，并且添加到WindowManager中，而WindowManager的addView中会创建ViewRootImpl，这个时候

   如果在该子View中更新创建的View，是不会报错的，因为ViewRootImpl是在子线程中创建；

   Activity也是一个Window,Window的添加是ActivityThread的handleResumeActivity()方法中，而这个方法是在主线中，所以

   Activtiy中的View只能被UI主线程访问；

   并且既然Activity Window的添加是在onResume之后，那么ViewRootImpl也是在onResume之后创建，所以在onCreate中创建子线程

   在短时间内更新Activity的UI是不会报错的，因为ViewRootImpl还没有创建;

   Toast可以在子线程中show吗？

   是可以的，因为Toast就是一个Window，show就是添加Window的过程 

35.Android 屏幕的刷新机制

   -在一个典型的显示系统中,主要包括CPU、GPU、Display三个部分，CPU负责计算数据，

   把计算好的数据交给GPU,GPU负责对图形数据进行渲染，渲染好的数据放到Buffer中

   然后Display(屏幕或者叫显示器)负责从Buffer中取出渲染好的图形数据显示;

   我们在开发过程中，是接触不到GPU和Display层面的，我们可以把这两部分的工作

   叫做底层工作，也就是除了CPU计算数据之外的的工作

   而在Android 中CPU计算屏幕数据的主要就是指View树的绘制过程,也就是Activity中

   从View树根布局DecoreView开始层层遍历每个子View，分别执行测量、布局、绘制的过程;

   那么我们通常所说的Android每个16.6ms刷新一次是指：底层以固定的频率,比如16.6ms

   从Buffer中取出GPU渲染后的图形数据显示;
   
   -从源码跟一下刷新的流程

    对于一个View他肯定是有一个父View-ViewGroup,布局的根View的ViewGroup是什么呢

    实际上是DecoreView,DecoreView是被添加到PhoneWindow中的，一个

    Activity实际上就会有一个PhoneWindow;
 
    那我们再来看下这个PhoneWindow是什么时候创建的?

    因为一个Activity对应一个PhoneWindow,那这个PhoneWindow应该是在Activity创建的时候

    创建的;查看源码我们就能够知道

    ActivityThread.handleLaunchActivity()--->ActivityThread.performLaunchActivity()

    --->Activity.attach()
        
        attach方法中创建的PhoneWindow

        mWindow = new PhoneWindow(this, window, activityConfigCallback);

    --->Activity.setContentView()--->PhoneWindow.setContentView()--->

    --->PhoneWindow.installDecor()（首先为PhoneWindow创建一个DecorView,这个DecoreView
   
    这个DecoreView也就是Activity的最顶级的View容器，之所以会创建一个这个DecoreView，是使用

    它来给Activity做一些基本的显示设置，比如状态栏颜色、背景什么的，这个DecoreView是继承自

    FragmeLayout的，而我们setContentView设置的布局，最终都是被转成View添加到DecoreView上的 
    
    ）--->LayoutInflater.inflate(layoutResID, mContentParent) (解析我们的设置的布局文件，

    将布局文件中的控件解析出View最终添加到DecoreView中

    )  

    目前到达这一步是Activtiy启动ActivityThread.handleLaunchActivity()，创建一个对应的PhoneWindow

    以及创建一个根View DecoreView，并且把我们设置的布局添加到DecoreView中，但是实际到目前为止，并没有

    把DecoreView添加到PhoneWindow中,

    那么是什么时候把DecoreView添加到PhoneWindow中的呢？

    实际是在Activity的onResume之后，因为是在ActivityThread.handleResumeActivtiy()中,并且是在

    ActivityThread.performResumeActivity()之后

    即ActivityThread.handleResumeActivtiy()--->WindowManager.addView(decor, l);

    以上就是我们为Activity设置布局，这个布局是怎么添加到Activity对应的PhoneWindow中的；

    但是还没有涉及到View的绘制，View添加之后，还要绘制才能够显示；

    那么根据上面的源码跟踪我们应该知道是在WindowManager.addView(decor, l)后开始进行绘制的

    然后显示所以我们继续从WindowManager.addView(decor, l)开始跟踪

    WindowManager.addView(decor, l)--->WindowManagerImpl.addView()--->

    WindowManagerGlobal.addView()--->ViewRootImpl.setView()--->ViewRootImpl.requestLayout()

    --->ViewRootImpl.scheduleTraversals()--->  

    mChoreographer.postCallbackChoreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);

    --->ViewRootImpl.doTraversal()--->ViewRootImpl.performTraversals()--->

        ViewRootImpl.perfromMeasure() --->View.measure()--->View.onMeasure()

        ViewRootImpl.performLayout()--->View.layout()--->View.onLayout() 

        ViewRootImpl.performDraw()--->ViewRootImpl.draw()--->ViewRootImpl.drawSoftware()

        --->View.draw()--->View.onDraw()

  以上的UI绘制流程是我们启动一个Activity，设置布局，这个布局中的View从添加到绘制的流程；
  
  那么我们的Activity中已绘制的View刷新，也就是重新绘制的流程是什么样的？
  
  我们知道我们一般需要刷新一个View,也就是希望重新绘制一个View，一般都是调用View的View.invalidate()方

  法或者View.requestLayout()方法;

  -我们先跟一下View.invalidate():

  View.invalidate()--->View.invalidate(true)--->View.invalidateInternal()

  --->ViewParent.invalidateChild()
       
      ViewGroup.invalidateChild() (ViewGroup.invalidateChild方法中是一个do-while循环
      
      循环中不断的获取View的ViewParent调用invalidateChild方法，直到到达DecoreView,DecoreView

      的ViewParent是ViewRootImpl

      )

      --->ViewRootImpl.invalidateChild()--->ViewRootImpl.invalidateChildInParent()

      --->ViewRootImpl.invalidateRectOnScreen()--->ViewRootImpl.scheduleTraversals()

      --->mChoreographer.postCallbackChoreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);

       --->ViewRootImpl.doTraversal()--->ViewRootImpl.performTraversals()--->

        ViewRootImpl.performDraw()--->ViewRootImpl.draw()--->ViewRootImpl.drawSoftware()

        --->View.draw()--->View.onDraw()

  总结：View.invalidate方法()首先是不断的调用父View的invalidateChild()方法,最终是调用

  ViewRootImpl.scheduleTraversals()方法，也就是进入到上面我们分析Activity启动时布局的绘制过程

  实现View的重新绘制，也就是刷新;但是要注意的是和启动Activity绘制布局不同的是，invalidate只会引起

  调用者的draw也就是绘制，不会引起重新measure和layout
  
  -我们再来跟一下View.requestLayout过程

   View.requestLayout()--->ViewParent.requestLayout() 

   (这就是一个递归调用requestLayout的过程，不断的调用父ViewPrent.requestLayout方法，

   最终就是到DecoreView的ViewParent也就是ViewRootImpl的requestLayout方法
   ）
   
   --->ViewRootImpl.requestLayout()--->View.scheduleTraversals()--->

   mChoreographer.postCallbackChoreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);

    --->ViewRootImpl.doTraversal()--->ViewRootImpl.performTraversals()--->

        ViewRootImpl.perfromMeasure() --->View.measure()--->View.onMeasure()

        ViewRootImpl.performLayout()--->View.layout()--->View.onLayout() 

  总结：View.requestLayout()法就是不断的调用父ViewParent的requestLayout方法，最终调用到

  ViewRootImpl的requestLayout方法，然后就是和启动Activity，布局的测量布局一样，但是不会

  进行绘制过程；

  综合总结：对于View.invalidate()方法和View.requestLayout()方法：

  调用View.invalidate()方法刷新适用于显示的内容需要改变，而View的大小和位置没有发生改变

  的情况，因为只会进行View自身的重新绘制，不会重新测量和布局;

  而View.requestLayout()适用于View的大小或者位置发生改变，而显示内容没有发生改变的情况，

  会层层调用父View进已经当前View进行重新测量布局，不会进行重新绘制；

  如果希望重新测量布局绘制，也就是大小位置显示内容都发生改变，

  需要同时调用requestLayout和invalidate两个方法;

  ProcessOn / XMind 

36.AsyncTask

   原理： ThreadPoolExecutor + Handler (线程池创建线程、Handler切换到主线程)

37.Base64数据编码
  
  将任意的二进制数据，转成可见的字符串数据;

  编码过程： 将二进制数据字节按照每3个字节进行编码，每3个字节编码之后变成4个可见字节

            如果一个数据有6个字节，编码后就变成6/3*4=8个字节

            如果二进制数据长度不是3的倍数，那最后的数据就要进行填充操作，即补 “=”

            这里的"="是填充字符

38.Android中的容器View都是直接或者间接继承自ViewGroup的

   ViewPager,RecycleView，LinearLayout,RelativeLayout等都是继承自

   ViewGroup的
   
   -Android 中的自定义View的步骤：

    如果不是容器View:

    继承自View

    测量  onMeasure  确定这个View的宽和高

    布局  onLayout   确定View的位置

    绘制  onDraw     确定View到底显示的是什么

    - 测量 onMeasure(int widthMeasureSpec,int heightMeasureSpec)

    测量的的回调方法中的widthMeasureSpec和heightMeasureSpec都是父View在onMeasure

    中调用当前View的measure方法传递进来的；

    那父View自身在测量也就是在onMeasure中到底是怎么计算出子View的widthMeasureSpec

    和heightMeasureSpec的;

    这个计算过程实际上就是将子View布局文件中设置的layout_width或者layout_height

    也就是通过子View的LayoutParams中的width和height来计算出widthMeasureSpec和

    heightMeasureSpec

    具体的计算方法ViewGroup已经提供了 getChildMeasureSpec(int spec, int padding, int 

    childDimension) 这个方法就是ViewGroup中提供的计算子View的measpreSpec的;

    三个参数值：

    spec : 计算子View的widthMeasureSpec 那就要传入当前父View的widthMeasureSpec

           如果是计算子View的heightMeasureSpec,那就传入当前父View的heightMeasureSpec
    
    padding：如果是计算子View的widthMeasureSpec时，那传入的就是当前父View的的paddingLeft+paddingRig         
             ht的值，因为子View的宽最多只能是 父View的宽-paddingLeft-paddingRight

             如果计算的是子View的heightMeasureSpec,那就是当前父View的paddingTop+paddingBottom的值

             ，因为子View的高最多只能是 父View的高-paddingTop-paddingBottom

    childDimension:就是子View的LayoutParams中的width或者height,如果是计算子View的

                   widthMeasureSpec，那传入的就是子View的LayoutParams.width,如果

                   计算的是子View的heightMeasureSpec,那传入的就是子View的LayoutParams.height

                   实际也就是子View在布局文件中中设置的layout_width或者layout_height

    注意：LayoutParams 中的 width height就是布局中的layout_width和layout_height

    -布局 onLayout(boolean changed,int l, int t, int r, int b) 布局
          
          如果不是ViewGroup,onLayout一般不用重写；

          如果是ViewGroup,onLayout中主要就是计算子View的left,top,right,bottom以此来

          设置子View的布局,调用各个子View的layout方法；

    -绘制 onDraw

     就是绘制要显示的内容     

     -MeasureSpec中三种测量模式

      UNSPECIFIED   父View没有对子View的大小限制 

      EXACTLY       父View指定了子View的确切大小 来供子View参考

      AT_MOST       父View指定了一个最大大小 来供子View参考

      onMeasure 方法中的widthMeasureSpec,heightMeasureSpec只是父View

      提供给子View用来参考设置大小的，最终的大小还是由子View自己决定的;

      注意：一般情况下，只要onMeasure中的widthMeasureSpec,heightMeasureSpec

      中获取的测量模式是EXACTLY,也就是父View给你指定了一个确切大小，那一般最好

      使用这个确切大小就好了；
      
      但是如果获取到的测量模式不是EXACTLY,那如果自己是ViewGroup，那一般就是根据

      子View的宽和高来计算自己的宽和高；如果是View那就根据自己的内容来设置大小；

39.View的getWidth,getHeight,getMeasureWidth,getMeasureHeight

   getWidth和getHeight,以及getMeasureWidtg,getMeasureHeight都可以

   获取到View的宽和高；

   但是getWidth以及getHeight只能是在View布局onLayout之后，才能获取到

   因为getWidth是mRight-mLeft;getHeight是mBottom-mTop;

   而getMeasureWidth以及getMeasureHeight是在测量onMeasure之后就可以

   获取到了;

40.Android系统的启动过程

   -Android系统的启动过程

   我们知道Android系统的内核是基于Linux内核的，所以当我们开机时，Linux系统被启动的时候

   首先会启动一个名字叫Zygote的Linux程序,这个程序实际上就是Android系统的内核,然后这个

   Zygote程序会fork第一个Davlik进程SystemServer进程，系统服务进程中就运行着许多系统服务

   如果ActivityManagerService,WindowManagerService,PackgerManagerService等等系统服务

   系统服务进程初始化完毕之后就会启动Launcher应用，也就是系统桌面应用;

   而Launcher应用就会显示我们已经安装的其它应用程序图标，点击图标就进入了一个启动另外一个应用的

   流程;

   而我们知道Android中的每一个应用都是在一个单独的进程中运行的，而每一个应用的进程都是由Zygote进程

   fork而来的;
   
   总结：

   Linux内核的启动 Zygote进程--->SystemServer进程的创建与初始化--->Launcher应用启动 

   --->APP的启动 

  -Android应用的启动过程

   Activity的startActivity--->Instrumentation.execStartActivity--->

   ActivityManagerService--->ActivityThread/ApplicationThread是实现了IApplicationThread的接口

   应用进程与AMS之间进程通信就是通过ApplicationThread AIDL通信的

   --->ActivityThread/handleLaunchActivity
      
       ActivityThread/handleStartActivity

       ActivityThread/handleResumeActivity

       













    































           
  


   
   





























   
    

   





























   








































   









   





  
     














   







   











    



 


   



























































      












      



















       
     





      






















       










   

     












   
    