1.C++简介
C++是面向对象的，全面兼容C语言(C语言中的内容完全可以在C++中使用)，可以认为C++是一门更好的C语言。

C和C++的区别：
(1)源文件后缀名
C语言的源文件的后缀名是.c
C++的源文件的后缀名是.cpp

(2)引用的头文件
C语言引用的头文件一般是<stdio.h>
C++引用的头文件一般是<iostream.h>
当然C++也是可以引用<stdio.h>头文件的，因为C++是全面兼容C语言的。

(3)输出
int a=1;
C语言中输出 printf("%d\n",a); \n表示换行
C++中输出  count<<a<<endl; endl表示换行

(4)C语言必须要在执行任意语句之前先定义变量，而C++可以在用的时候定义。

(5)C语言中不允许函数的重载，C++允许函数的重载


(6)C++有命名空间的概念

C++中一般引用的头文件
#include<iostream>
using namesapce std;  (count等都是std命名空间中的)
而不用
#include<iostream.h>
因为<iostream.h>是比较老的头文件，不带.h的<iostream>头文件是比较新的头文件。
但是用不带.h的头文件<iostream> 需要使用命名空间 using namesapce std;

(7)自定义数据类型
 C语言中用struct结构体定义自定义数据类型。
 C++中除了struct外，还引入了类(class)的概念。

(8)C语言是面向过程的，C++是面向对象的。


 这里再强调一下：C++是全面支持C语言的。

2.类与对象

  C++的四大对特征:抽象，封装，继承，多态
 
  C++是支持多继承的(Java是单继承的)；

  类的定义:
  class 类名{
      
  };

  
  访问权限修饰符: public,protected,private

  默认的访问权限修饰符是private

  只有公有成员(成员变量，成员方法),才能够通过 对象名.成员 来访问。


  ::(作用域解析符)
  当需要在类外实现类的成员函数，需要使用作用域解析符来指明实现的是哪个类中的方法

  void Student::setId(int id){
   this->id=id;
  }


  对象的实例化:
   (1)直接定义类的实例
    Student student;
    创建了Student类的一个对象，同时为它分配了存储空间
   (2)动态创建类的对象的方法（使用new关健字创建）   

3.this指针
  this指针 代表的是当前对象的地址

4.const(常量)

int * p
const int * p;
int const * p;

int * const p;
const int * const p;

const如果在 * 的左边 则表示 *P是常量 不能够通过指针p修改p指向的内容。
const如果在 * 的右边 则表示 p(指针)是常量,指针不能改变指向 
如果*的左边右边都有，则 *p,p都是常量,即指针p,以及指针p指向的内容都是常量，都不可变。

5.构造函数，析构函数，拷贝函数，赋值语句(C++四少)
  
-构造函数
  构造函数:函数名与类名一样，没有返回值类型
  一个类中可以有多个构造函数。
   
  public:
      Student(){

      }  

      Student(int id){
      this->id=id;
      }

      Student(string name){
      this->name=name;
      }

      Student(int id,string name){
      this->id=id;
      this->name=name;
      }
   

   //使用不同构造函数实例化对象

     Student student;     //调用的是无参构造函数实例化
     Student student(1);  
     Student student("张三");
     Student student(1,"张三");
   
   上面几个构造函数函数名一致，参数不同(参数个数，参数类型)，说明构造函数可以重载。

   与Java中一样，如果没有给出构造函数，那么C++中的类会有一个默认的无参构造函数。
   如果你在类中写了构造函数，那么系统就不会提供这个默认的构造函数。

      

   类的默认构造函数只能有一个，
   构造函数没有参数，
    public:
          Student(){

         } 
   构造函数有参数，但是所有的参数都有默认值
     public:
        Student(int id=0){

        }

    这样的构造函数都是系统认为的默认的构造函数 ，类中只能存在一个;



    还有我们在实例化的时候一定要注意：
    
    Student student; //这是调用无参的构造函数实例化对象。

    但是一定不要这样写: Student student();
    这样写编译不会报错，运行也不会报错，但是这不是实例化对象，而是声明一个函数，
    所以不要认为student()是实例化对象。


    构造函数的三个作用:
    (1) 实例化对象
        
         Student student;
         上面就是由无参的构造方法实例化一个Student的对象

    (2) 成员变量的初始化
      public :
       Student(int id){
       this->id=id;
       }
       这也比较好理解，我们一般在构造方法里对成员变量进行初始化

    (3) 类型的转换
       public :
       Student(){

       }
       Student(int id){
       this->id=id;
       }
      
       Student student;
       int t=10;
       student=t;  //这是可以赋值的，这是因为Student有一个Student(iny id)构造方法，这里会调用这个构造方法创建一个临时的Student对象，然后把这个临时对象赋值给student。
       如果Student类中没有这个具有一个整型的参数的构造方法，那么就不能这样赋值了(student=t)
       cout<<student.getId()<<endl; //打印出是10

       这是构造方法一个比较特殊的作用。


-析构函数
   析构函数：是用来释放对象占用的内存空间的。
   当一个对象的生命周期结束时，C++会自动调用一个函数注销该对象，释放相应的内存空间。

   析构函数的名字: ~类名,没有返回值类型,析构函数不能有任何参数。
   一个类析只能有一个析构函数。
   如果类中没有给出析构函数，系统会提供一个默认的析构函数。

-拷贝构造函数
   
  学习拷贝函数之前，先来学习一下引用的概念：
  引用:

  我们先来看两个函数
  void swap1(int x,int y){
   int temp=x;
   x=y;
   y=temp;
  }

   int a=1;
   int b=2;
   swap1(a,b);

   cout<<a<<","<<b<,endl;  //打印结果:1,2 ; a,b并没有交换。
   
  void swap2(int *x,int *y){
  int temp=*x;
  int *x=*y;
  int *y=temp;
  }
    int a=1;
    int b=2;
    swap2(&a,&b);
  cout<<a<<","<<b<<endl; //打印结果: 2,1 ;  a,b 发生交换了。

  
  引用符号:& (引用就是别名)

  void swap3(int &x,int &y){
  int temp=x;
  int x=y;
  int y=temp;
  }
    int a=1;
    int b=2;
    swap3(a,b);
  cout<<a<<","<<b<<endl; //打印结果: 2,1 ;  a,b 发生交换了。
  
  引用：
  (1)引用不是一个新的变量，是另外一个变量的别名
   int a=1;
   int &b=a;
  (2)引用不能是空引用，必须是已有变量的一个引用
   int &b; //这样定义是不允许的

   拷贝构造函数:
   在创建一个类的对象时可以用这个类的另外一个对象来初始化,这时候调用的是拷贝构造函数。
   
   Student stu1;
   Student stu2(stu1); //这里调用的就是拷贝构造函数
   
   拷贝构造函数的名字与类名相同，且参数是该类对象的引用
   Student(Student &stu){
    this->id=stu.id;
   }

   如果类中没有提供拷贝构造函数，系统会提供一个默认的拷贝构造函数。
   
   拷贝构造函数会在三种情况下会被调用:
   
   (1)在创建一个类的对象时可以用这个类的另外一个对象来初始化,这时候调用的是拷贝构
    Student stu1;
    Student stu2(stu1);
    或
    Student stu1;
    Student stu2=stu1;
    这都属于对象的初始化。
   
   (2)如果函数的参数是类的对象时，则调用这个函数时，会调用拷贝构造函数
      void fun(Student student){
       
      }
     
     调用函数时，进行实参与形参的传递时，这是要在内存中新建一个局部对象，然后把实参拷贝到新的对象中。

     
   (3) 当函数的返回值是类的对象时 ，调用该函数时，会调用拷贝构造函数
       因为局部对象在离开建立它的函数时就消亡了，不可能在返回调用函数后继续生存，所以编译器
       系统会在调用函数的表达式中创建一个无名临时对象，该临时对象的生存周期只在函数调用处的表达式
       中，所谓return对象，实际上是调用拷贝构造函数把函数中对象的值拷贝给临时对象。
    
       后面两种情况本质上也是第一种情况，即用对象初始化对象。
    
-赋值函数
 
 赋值函数的名字就是 operator=(实际上这里就是运算符"="的重载)

 返回类型 operator = (参数类型 参数){
          

  }

 上面是赋值函数的基本形式,
 一般写成这种:

 Student& operator =(const Student &stu){
      this->id=stu.id;
      return *this;
 }



 Student stu1;
 Student stu2;
 stu2=stu1;  //这就是赋值(赋值的时候，会调用赋值函数)
 
 这里实际上就是 stu2.operator=(t1);(stu2调用operator=方法)；
  

 注意:下面这个不是赋值，而是对象的初始化(调用的是拷贝构造函数)
  Student stu1;
  Student stu2=stu1;






  

  



   


     